# Ent ORM Implementation Guide

> **Template Version:** 1.0.0  
> **Compatible OIML Versions:** 0.1.x  
> **Compatible Ent Versions:** 0.12.x, 0.13.x, 0.14.x  
> **Last Updated:** 2025-01-27

This guide provides complete implementation instructions for applying OpenIntent data intents when using Ent as the database ORM framework.

## When to Use This Guide

Use this guide when `database.framework` in `project.yaml` is set to `"ent"`.

## Prerequisites

- Go 1.18+ is installed
- Ent is installed: `go get entgo.io/ent/cmd/ent`
- Database driver is installed (e.g., `github.com/lib/pq` for PostgreSQL)
- `ent/schema/` directory exists for schema definitions
- `ent/generate.go` file exists with generation directive

## Project Structure

```
project/
├── ent/
│   ├── generate.go          # Code generation directive
│   ├── schema/              # Schema definitions
│   │   ├── user.go
│   │   └── {entity}.go
│   └── (generated files)    # Auto-generated by ent
├── go.mod
└── main.go
```

## Field Type Mappings

### OpenIntent Type → Ent Type

| OpenIntent Type | Ent Type    | Ent Method        | Notes                |
| --------------- | ----------- | ----------------- | -------------------- |
| `string`        | `string`    | `field.String()`  | Text field           |
| `text`          | `string`    | `field.String()`  | Long text content    |
| `integer`       | `int`       | `field.Int()`     | 32-bit integer       |
| `bigint`        | `int64`     | `field.Int64()`   | 64-bit integer       |
| `float`         | `float64`   | `field.Float64()` | Floating point       |
| `boolean`       | `bool`      | `field.Bool()`    | True/false value     |
| `datetime`      | `time.Time` | `field.Time()`    | Date and time        |
| `date`          | `time.Time` | `field.Time()`    | Date only            |
| `uuid`          | `string`    | `field.UUID()`    | UUID string          |
| `json`          | `any`       | `field.JSON()`    | JSON data            |
| `enum`          | Custom type | `field.Enum()`    | Requires enum values |
| `array`         | `[]Type`    | `field.Strings()` | Array of strings     |
| `bytes`         | `[]byte`    | `field.Bytes()`   | Binary data          |

### Field Attributes

| OpenIntent Attribute | Ent Implementation                             | Database Impact                           |
| -------------------- | ---------------------------------------------- | ----------------------------------------- |
| `required: true`     | No `.Optional()` call                          | NOT NULL constraint                       |
| `required: false`    | Add `.Optional()`                              | NULL allowed                              |
| `unique: true`       | Add `.Unique()`                                | **Creates UNIQUE constraint in database** |
| `default: value`     | Add `.Default(value)`                          | DEFAULT value in database                 |
| `max_length: N`      | Add `.MaxLen(N)` for strings + `.SchemaType()` | **VARCHAR(N) constraint in database**     |

**Important**:

- When `unique: true` is specified, `.Unique()` **must** be called on the field. This creates a database-level UNIQUE constraint that prevents duplicate values. After regenerating Ent code, you **must** run migrations to apply this constraint to the database.
- When `max_length: N` is specified, **both** `.MaxLen(N)` **and** `.SchemaType()` should be used to ensure the database column respects the constraint:

  ```go
  field.String("email").
      MaxLen(255).
      SchemaType(map[string]string{
          "postgres": "varchar(255)",
          "mysql":    "varchar(255)",
          "sqlite3":  "varchar(255)",
      })
  ```

  - `.MaxLen(N)` provides application-level validation
  - `.SchemaType()` ensures the database column type is `VARCHAR(N)`, enforcing the constraint at the database level
  - **Without `.SchemaType()`**, Ent may create columns without size constraints, especially for existing columns
  - **With `.SchemaType()`**, Ent will create columns with the correct `VARCHAR(N)` type, ensuring `max_length` is respected

### Special Default Values

- `default: "uuid"` → `.Default(uuid.New)` (requires `github.com/google/uuid`)
- `default: "now"` → `.Default(time.Now)` (for time fields)
- `default: "autoincrement"` → Use `.Int()` with auto-increment in database

## Implementing `add_entity` Intent

### Steps

1. **Read the intent** and extract:
   - Entity name (PascalCase)
   - Array of fields with their types and attributes

2. **Create schema file** in `ent/schema/{entity_lower}.go`:

   ```go
   package schema

   import (
       "entgo.io/ent"
       "entgo.io/ent/schema/field"
   )

   // {EntityName} holds the schema definition for the {EntityName} entity.
   type {EntityName} struct {
       ent.Schema
   }

   // Fields of the {EntityName}.
   func ({EntityName}) Fields() []ent.Field {
       return []ent.Field{
           field.Int("id").
               Positive().
               Unique(),
           field.String("field1").
               MaxLen(255),
           field.String("field2").
               Optional(),
           // ... more fields
       }
   }

   // Edges of the {EntityName}.
   func ({EntityName}) Edges() []ent.Edge {
       return []ent.Edge{
           // Relations go here
       }
   }
   ```

3. **Add enum definitions** (if needed) using `field.Enum()`:

   ```go
   field.Enum("status").
       Values("ACTIVE", "INACTIVE", "PENDING").
       Default("ACTIVE")
   ```

4. **Generate Ent code**:

   ```bash
   go generate ./ent
   ```

   Or manually:

   ```bash
   go run -mod=mod entgo.io/ent/cmd/ent generate ./ent/schema
   ```

   This regenerates the Ent client code but **does not** update the database schema.

5. **Apply migrations** (only if `database.autorun_migrations` is `true` in `project.yaml`) - **CRITICAL**: Migrations are always created when Ent code is regenerated, but must be applied to update the database:

   **CRITICAL:** Before applying migrations, check `project.yaml` for `database.autorun_migrations`:
   - If `database.autorun_migrations: true`: Apply migration automatically:
     ```go
     if err := client.Schema.Create(context.Background()); err != nil {
         log.Fatalf("failed creating schema resources: %v", err)
     }
     ```
   - If `database.autorun_migrations: false` or not set: Migration is ready but not applied. Apply manually when ready:
     ```go
     // Migration ready - apply manually when ready:
     // if err := client.Schema.Create(context.Background()); err != nil {
     //     log.Fatalf("failed creating schema resources: %v", err)
     // }
     ```

   **Note**: Migrations are created when Ent code is regenerated (`go generate ./ent`), but without applying migrations (`client.Schema.Create()`), unique constraints, NOT NULL constraints, and other database-level changes will **not** be applied to the database.

### Example: Adding a Customer Entity

**Intent:**

```yaml
- kind: add_entity
  scope: data
  entity: Customer
  fields:
    - name: id
      type: integer
      required: true
    - name: email
      type: string
      max_length: 255
      required: true
      unique: true
    - name: name
      type: string
      max_length: 100
      required: true
    - name: status
      type: enum
      enum_values: [ACTIVE, INACTIVE, PENDING]
      required: true
      default: ACTIVE
    - name: created_at
      type: datetime
      required: true
      default: now
```

**Generated Ent Schema:**

```go
package schema

import (
    "time"
    "entgo.io/ent"
    "entgo.io/ent/schema/field"
)

// Customer holds the schema definition for the Customer entity.
type Customer struct {
    ent.Schema
}

// Fields of the Customer.
func (Customer) Fields() []ent.Field {
    return []ent.Field{
        field.Int("id").
            Positive().
            Unique(),
        field.String("email").
            MaxLen(255).
            SchemaType(map[string]string{
                "postgres": "varchar(255)",
                "mysql":    "varchar(255)",
                "sqlite3":  "varchar(255)",
            }).
            Unique(),
        field.String("name").
            MaxLen(100).
            SchemaType(map[string]string{
                "postgres": "varchar(100)",
                "mysql":    "varchar(100)",
                "sqlite3":  "varchar(100)",
            }),
        field.Enum("status").
            Values("ACTIVE", "INACTIVE", "PENDING").
            Default("ACTIVE"),
        field.Time("created_at").
            Default(time.Now),
    }
}

// Edges of the Customer.
func (Customer) Edges() []ent.Edge {
    return []ent.Edge{}
}
```

## Implementing `add_field` Intent

### Steps

1. **Verify the entity exists** in `ent/schema/{entity_lower}.go`

2. **Locate the `Fields()` method** in the schema file

3. **Add new fields** to the `Fields()` return array following the field type mappings
   - **For `unique: true`**: Always add `.Unique()` - this creates a database UNIQUE constraint
   - **For `required: true`**: Do NOT add `.Optional()` - this creates a NOT NULL constraint
   - **For `required: false`**: Add `.Optional()` - allows NULL values
   - **For `max_length: N`**: Add `.MaxLen(N)` **and** `.SchemaType()` for string fields to ensure database-level enforcement:
     ```go
     field.String("field_name").
         MaxLen(255).
         SchemaType(map[string]string{
             "postgres": "varchar(255)",
             "mysql":    "varchar(255)",
             "sqlite3":  "varchar(255)",
         })
     ```

4. **Add enum definitions** (if needed) using `field.Enum()`

5. **Regenerate Ent code**:

   ```bash
   go generate ./ent
   ```

   This regenerates the Ent client code but **does not** update the database schema.

6. **Apply migrations** (only if `database.autorun_migrations` is `true` in `project.yaml`) - **CRITICAL**: Migrations are always created when Ent code is regenerated, but must be applied to update the database:

   **CRITICAL:** Before applying migrations, check `project.yaml` for `database.autorun_migrations`:
   - If `database.autorun_migrations: true`: Apply migration automatically:
     ```go
     if err := client.Schema.Create(context.Background()); err != nil {
         log.Fatalf("failed creating schema resources: %v", err)
     }
     ```
     Or use Ent's migration tools to generate SQL migrations for production.
   - If `database.autorun_migrations: false` or not set: Migration is ready but not applied. Apply manually when ready:
     ```go
     // Migration ready - apply manually when ready:
     // if err := client.Schema.Create(context.Background()); err != nil {
     //     log.Fatalf("failed creating schema resources: %v", err)
     // }
     ```

   **Note**: Migrations are created when Ent code is regenerated (`go generate ./ent`), but without applying migrations (`client.Schema.Create()`), unique constraints, NOT NULL constraints, and other database-level changes will **not** be applied to the database.

   **Important Note on MaxLen() and SchemaType()**:
   - **For new fields**: Always use both `.MaxLen(N)` and `.SchemaType()` to ensure the database column type is `VARCHAR(N)`:

     ```go
     field.String("field_name").
         MaxLen(255).
         SchemaType(map[string]string{
             "postgres": "varchar(255)",
             "mysql":    "varchar(255)",
             "sqlite3":  "varchar(255)",
         })
     ```

     - `SchemaType()` ensures new columns are created with the correct `VARCHAR(N)` type

   - **For existing fields**: Ent's auto-migration (`client.Schema.Create()`) **does not alter existing columns** even with `SchemaType()`. You **must** manually alter existing columns:

     ```sql
     -- PostgreSQL example
     ALTER TABLE users ALTER COLUMN first_name TYPE VARCHAR(255);
     ```

     - **Note**: In PostgreSQL, the column type will show as `character varying` in `information_schema`, but this is equivalent to `varchar`. Check `character_maximum_length` to verify the size constraint.
     - **Alternative for development**: Drop and recreate the table
     - **For production**: Use Ent's Atlas migration tools to generate explicit SQL migrations

   **CRITICAL Note on API Endpoints**: When adding fields to an entity, you **must** update any existing POST/PATCH endpoints for that entity to accept the new fields:
   - **For required fields**: Add them to the request body struct with `binding:"required"`
   - **For optional fields**: Add them as pointer types (`*string`, `*int`, etc.) so they can be `nil` if not provided
   - Update the entity creation code to conditionally set optional fields only if they're not nil
   - Update TypeScript types in `packages/types/index.ts` if using TypeScript API layer
   - Example for optional fields:

     ```go
     var body struct {
         RequiredField string  `json:"required_field" binding:"required"`
         OptionalField *string `json:"optional_field"`
     }

     create := client.Entity.Create().SetRequiredField(body.RequiredField)
     if body.OptionalField != nil {
         create = create.SetOptionalField(*body.OptionalField)
     }
     entity, err := create.Save(context.Background())
     ```

   **IMPORTANT:** After adding fields:
   1. Regenerate Ent code: `go generate ./ent` (creates migrations)
   2. Apply migrations (only if `database.autorun_migrations: true`): `client.Schema.Create(context.Background())`
   3. Update API endpoints to accept new fields
   4. Update response types if needed

### Example: Adding Fields to Customer

**Intent:**

```yaml
- kind: add_field
  scope: data
  entity: Customer
  fields:
    - name: phone
      type: string
      max_length: 20
      required: false
    - name: birthday
      type: date
      required: false
    - name: email
      type: string
      max_length: 255
      required: true
      unique: true
```

**Updated Ent Schema:**

```go
func (Customer) Fields() []ent.Field {
    return []ent.Field{
        field.Int("id").
            Positive().
            Unique(),
        field.String("email").
            MaxLen(255).
            SchemaType(map[string]string{
                "postgres": "varchar(255)",
                "mysql":    "varchar(255)",
                "sqlite3":  "varchar(255)",
            }).
            Unique(),  // Creates UNIQUE constraint in database
        field.String("name").
            MaxLen(100).
            SchemaType(map[string]string{
                "postgres": "varchar(100)",
                "mysql":    "varchar(100)",
                "sqlite3":  "varchar(100)",
            }),
        field.String("phone").        // New field
            MaxLen(20).
            SchemaType(map[string]string{
                "postgres": "varchar(20)",
                "mysql":    "varchar(20)",
                "sqlite3":  "varchar(20)",
            }).
            Optional(),
        field.Time("birthday").       // New field
            Optional(),
        field.Enum("status").
            Values("ACTIVE", "INACTIVE", "PENDING").
            Default("ACTIVE"),
        field.Time("created_at").
            Default(time.Now),
    }
}
```

**After updating the schema:**

1. Regenerate Ent code: `go generate ./ent` (creates migrations)
2. **Apply migrations** (only if `database.autorun_migrations` is `true` in `project.yaml`) to apply the unique constraint to the database:

   **CRITICAL:** Before applying migrations, check `project.yaml` for `database.autorun_migrations`:
   - If `database.autorun_migrations: true`: Apply migration automatically:
     ```go
     if err := client.Schema.Create(context.Background()); err != nil {
         log.Fatalf("failed creating schema resources: %v", err)
     }
     ```
   - If `database.autorun_migrations: false` or not set: Migration is ready but not applied. Apply manually when ready:
     ```go
     // Migration ready - apply manually when ready:
     // if err := client.Schema.Create(context.Background()); err != nil {
     //     log.Fatalf("failed creating schema resources: %v", err)
     // }
     ```

3. Verify the constraint was created:
   ```sql
   -- PostgreSQL example
   SELECT constraint_name, constraint_type
   FROM information_schema.table_constraints
   WHERE table_name = 'customers' AND constraint_type = 'UNIQUE';
   ```

## Implementing `add_relation` Intent

### Relation Types

| OpenIntent Relation | Ent Implementation                                  |
| ------------------- | --------------------------------------------------- |
| `one_to_one`        | `edge.To()` on one side, `edge.From()` on other     |
| `one_to_many`       | `edge.To()` on many side, `edge.From()` on one side |
| `many_to_one`       | `edge.To()` on many side, `edge.From()` on one side |
| `many_to_many`      | `edge.To()` on both sides with `edge.From()`        |

### Steps for `many_to_one` Relation

1. **Verify both entities exist** in the schema directory

2. **Add edge to source entity** (many side):

   ```go
   import "entgo.io/ent/schema/edge"

   func ({SourceEntity}) Edges() []ent.Edge {
       return []ent.Edge{
           edge.To("{target_entity_lower}", {TargetEntity}.Type).
               Unique().
               Required(),
       }
   }
   ```

3. **Add reverse edge to target entity** (one side):

   ```go
   func ({TargetEntity}) Edges() []ent.Edge {
       return []ent.Edge{
           edge.From("{source_entity_plural}", {SourceEntity}.Type).
               Ref("{target_entity_lower}"),
       }
   }
   ```

4. **Regenerate Ent code**:

   ```bash
   go generate ./ent
   ```

5. **Apply migrations** (only if `database.autorun_migrations` is `true` in `project.yaml`) to update database schema:

   **CRITICAL:** Before applying migrations, check `project.yaml` for `database.autorun_migrations`:
   - If `database.autorun_migrations: true`: Apply migration automatically:
     ```go
     if err := client.Schema.Create(context.Background()); err != nil {
         log.Fatalf("failed creating schema resources: %v", err)
     }
     ```
   - If `database.autorun_migrations: false` or not set: Migration is ready but not applied. Apply manually when ready:
     ```go
     // Migration ready - apply manually when ready:
     // if err := client.Schema.Create(context.Background()); err != nil {
     //     log.Fatalf("failed creating schema resources: %v", err)
     // }
     ```

### Example: Todo → User Relation

**Intent:**

```yaml
- kind: add_relation
  scope: schema
  relation:
    source_entity: Todo
    target_entity: User
    kind: many_to_one
    field_name: user_id
    foreign_key:
      local_field: user_id
      target_field: id
    reverse:
      kind: one_to_many
      field_name: todos
```

**Updated Ent Schemas:**

`ent/schema/todo.go`:

```go
import "entgo.io/ent/schema/edge"

func (Todo) Edges() []ent.Edge {
    return []ent.Edge{
        edge.To("user", User.Type).
            Unique().
            Required(),
    }
}
```

`ent/schema/user.go`:

```go
func (User) Edges() []ent.Edge {
    return []ent.Edge{
        edge.From("todos", Todo.Type).
            Ref("user"),
    }
}
```

## Implementing `remove_field` Intent

### Steps

1. **Verify the entity and fields exist** in the schema

2. **Remove the fields** from the `Fields()` method return array

3. **Remove related enum references** if no longer used

4. **Regenerate Ent code**:

   ```bash
   go generate ./ent
   ```

   This regenerates the Ent client code but **does not** update the database schema.

5. **Apply migrations** (only if `database.autorun_migrations` is `true` in `project.yaml`) - **CRITICAL**: Migrations are always created when Ent code is regenerated, but must be applied to update the database:

   **CRITICAL:** Before applying migrations, check `project.yaml` for `database.autorun_migrations`:
   - If `database.autorun_migrations: true`: Apply migration automatically:
     ```go
     if err := client.Schema.Create(context.Background()); err != nil {
         log.Fatalf("failed creating schema resources: %v", err)
     }
     ```
   - If `database.autorun_migrations: false` or not set: Migration is ready but not applied. Apply manually when ready:
     ```go
     // Migration ready - apply manually when ready:
     // if err := client.Schema.Create(context.Background()); err != nil {
     //     log.Fatalf("failed creating schema resources: %v", err)
     // }
     ```

   **Note**: Migrations are created when Ent code is regenerated (`go generate ./ent`), but without applying migrations (`client.Schema.Create()`), field removals, constraint removals, and other database-level changes will **not** be applied to the database.

## Implementing `remove_entity` Intent

### Steps

1. **Verify the entity exists** in the schema directory

2. **Check for dependencies**:
   - Search for edges/relations in other entities that reference this entity
   - If `cascade: true` is specified, related data will be deleted automatically via ON DELETE CASCADE
   - If `cascade: false`, ensure no foreign keys reference this entity or handle them manually

3. **Remove relations** in other entities:
   - Open schema files for entities that have edges to this entity
   - Remove edge definitions that reference the entity being deleted
   - Update the `Edges()` method to remove these edges

4. **Delete the schema file**: `ent/schema/{entity_lower}.go`

5. **Regenerate Ent code**:

   ```bash
   go generate ./ent
   ```

   This regenerates the Ent client code but **does not** update the database schema.

6. **Apply migrations** (only if `database.autorun_migrations` is `true` in `project.yaml`) - **CRITICAL**:

   **CRITICAL:** Before applying migrations, check `project.yaml` for `database.autorun_migrations`:
   - If `database.autorun_migrations: true`: Apply migration automatically:
     ```go
     if err := client.Schema.Create(context.Background()); err != nil {
         log.Fatalf("failed creating schema resources: %v", err)
     }
     ```
   - If `database.autorun_migrations: false` or not set: Migration is ready but not applied. Apply manually when ready:
     ```go
     // Migration ready - apply manually when ready:
     // if err := client.Schema.Create(context.Background()); err != nil {
     //     log.Fatalf("failed creating schema resources: %v", err)
     // }
     ```

   **Note**: Ent's auto-migration may not drop tables by default. For production, you may need to:
   - Use explicit migration tools (Atlas)
   - Manually drop the table:
     ```sql
     -- Drop foreign key constraints first if cascade is false
     ALTER TABLE "related_table" DROP CONSTRAINT "fk_constraint_name";
     -- Then drop the table
     DROP TABLE "{entity_name}";
     ```

7. **Update application code**:
   - Remove all queries and operations using this entity
   - Remove API endpoints that reference this entity
   - Update any business logic that depended on this entity

### Example: Removing a Profile Entity

**Intent:**

```yaml
- kind: remove_entity
  scope: data
  entity: Profile
  cascade: false
```

**Before:**

`ent/schema/user.go`:

```go
func (User) Edges() []ent.Edge {
    return []ent.Edge{
        edge.To("profile", Profile.Type).
            Unique(),
    }
}
```

`ent/schema/profile.go`:

```go
package schema

import (
    "entgo.io/ent"
    "entgo.io/ent/schema/edge"
    "entgo.io/ent/schema/field"
)

type Profile struct {
    ent.Schema
}

func (Profile) Fields() []ent.Field {
    return []ent.Field{
        field.Int("id").Positive().Unique(),
        field.String("bio"),
    }
}

func (Profile) Edges() []ent.Edge {
    return []ent.Edge{
        edge.From("user", User.Type).
            Ref("profile").
            Unique().
            Required(),
    }
}
```

**After:**

1. Remove `ent/schema/profile.go` file entirely
2. Update `ent/schema/user.go` to remove the profile edge:

```go
func (User) Edges() []ent.Edge {
    return []ent.Edge{
        // profile edge removed
    }
}
```

3. Regenerate Ent code: `go generate ./ent`
4. Run migrations or manually drop the table

## Implementing `rename_entity` Intent

### Steps

1. **Verify the entity exists** in the schema directory

2. **Rename the schema file**:
   - From: `ent/schema/{old_entity_lower}.go`
   - To: `ent/schema/{new_entity_lower}.go`

3. **Update the struct definition** in the renamed file:

   ```go
   // Before
   type OldEntity struct {
       ent.Schema
   }

   // After
   type NewEntity struct {
       ent.Schema
   }
   ```

4. **Update all method receivers**:

   ```go
   // Before
   func (OldEntity) Fields() []ent.Field { ... }
   func (OldEntity) Edges() []ent.Edge { ... }

   // After
   func (NewEntity) Fields() []ent.Field { ... }
   func (NewEntity) Edges() []ent.Edge { ... }
   ```

5. **Update all references** in other entity schemas:
   - Update edge type references from `OldEntity.Type` to `NewEntity.Type`
   - Update import statements if needed
   - Example:

     ```go
     // Before
     edge.To("old_entity", OldEntity.Type)

     // After
     edge.To("new_entity", NewEntity.Type)
     ```

6. **Regenerate Ent code**:

   ```bash
   go generate ./ent
   ```

7. **Apply migrations** (only if `database.autorun_migrations` is `true` in `project.yaml`):

   **CRITICAL:** Before applying migrations, check `project.yaml` for `database.autorun_migrations`:
   - If `database.autorun_migrations: true`: Apply migration automatically:
     ```go
     if err := client.Schema.Create(context.Background()); err != nil {
         log.Fatalf("failed creating schema resources: %v", err)
     }
     ```
   - If `database.autorun_migrations: false` or not set: Migration is ready but not applied. Apply manually when ready:
     ```go
     // Migration ready - apply manually when ready:
     // if err := client.Schema.Create(context.Background()); err != nil {
     //     log.Fatalf("failed creating schema resources: %v", err)
     // }
     ```

   **Important**: Ent's auto-migration may create a new table instead of renaming. For production:
   - Use explicit migration with table rename:
     ```sql
     ALTER TABLE "{old_entity_name}" RENAME TO "{new_entity_name}";
     ```
   - Or use Ent's Atlas migration tools to generate proper rename migrations

8. **Update application code**:
   - Update all database queries using the old entity name
   - Update API routes and handlers
   - Update business logic and imports

### Example: Renaming Customer to Client

**Intent:**

```yaml
- kind: rename_entity
  scope: data
  from: Customer
  to: Client
```

**Steps:**

1. Rename file: `ent/schema/customer.go` → `ent/schema/client.go`

2. Update `ent/schema/client.go`:

**Before:**

```go
package schema

import (
    "entgo.io/ent"
    "entgo.io/ent/schema/field"
)

type Customer struct {
    ent.Schema
}

func (Customer) Fields() []ent.Field {
    return []ent.Field{
        field.Int("id").Positive().Unique(),
        field.String("email").MaxLen(255).Unique(),
        field.String("name").MaxLen(100),
    }
}

func (Customer) Edges() []ent.Edge {
    return []ent.Edge{}
}
```

**After:**

```go
package schema

import (
    "entgo.io/ent"
    "entgo.io/ent/schema/field"
)

type Client struct {
    ent.Schema
}

func (Client) Fields() []ent.Field {
    return []ent.Field{
        field.Int("id").Positive().Unique(),
        field.String("email").MaxLen(255).Unique(),
        field.String("name").MaxLen(100),
    }
}

func (Client) Edges() []ent.Edge {
    return []ent.Edge{}
}
```

3. If other entities reference Customer, update those as well
4. Regenerate code: `go generate ./ent` (creates migrations)
5. Apply migrations (only if `database.autorun_migrations: true`): `client.Schema.Create(context.Background())`
6. Manually rename table in database if needed:
   ```sql
   ALTER TABLE "customers" RENAME TO "clients";
   ```

## Implementing `rename_field` Intent

### Steps

1. **Verify the entity and field exist** in the schema

2. **Update the field definition** in `ent/schema/{entity_lower}.go`:
   - Change the field name in the `field.Type("field_name")` call
   - Maintain all field attributes (MaxLen, Unique, Optional, etc.)

3. **Update edge references** if the field is part of a relation:
   - If it's a foreign key field used in an edge, update the edge definition
   - Update corresponding edges in related entities

4. **Regenerate Ent code**:

   ```bash
   go generate ./ent
   ```

5. **Apply migrations** (only if `database.autorun_migrations` is `true` in `project.yaml`):

   **CRITICAL:** Before applying migrations, check `project.yaml` for `database.autorun_migrations`:
   - If `database.autorun_migrations: true`: Apply migration automatically:
     ```go
     if err := client.Schema.Create(context.Background()); err != nil {
         log.Fatalf("failed creating schema resources: %v", err)
     }
     ```
   - If `database.autorun_migrations: false` or not set: Migration is ready but not applied. Apply manually when ready:
     ```go
     // Migration ready - apply manually when ready:
     // if err := client.Schema.Create(context.Background()); err != nil {
     //     log.Fatalf("failed creating schema resources: %v", err)
     // }
     ```

   **Important**: Ent's auto-migration may create a new column instead of renaming. For production:
   - Manually rename the column:
     ```sql
     ALTER TABLE "{entity_name}" RENAME COLUMN "{old_field}" TO "{new_field}";
     ```
   - Or use Ent's Atlas migration tools to generate proper rename migrations

6. **Update application code**:
   - Update all queries using the old field name
   - Update API request/response structures
   - Update business logic that references this field

### Example: Renaming 'name' to 'full_name'

**Intent:**

```yaml
- kind: rename_field
  scope: data
  entity: Customer
  from: name
  to: full_name
```

**Before:**

```go
func (Customer) Fields() []ent.Field {
    return []ent.Field{
        field.Int("id").Positive().Unique(),
        field.String("email").MaxLen(255).Unique(),
        field.String("name").MaxLen(100),
        field.Time("created_at").Default(time.Now),
    }
}
```

**After:**

```go
func (Customer) Fields() []ent.Field {
    return []ent.Field{
        field.Int("id").Positive().Unique(),
        field.String("email").MaxLen(255).Unique(),
        field.String("full_name").MaxLen(100),
        field.Time("created_at").Default(time.Now),
    }
}
```

**Database Migration:**

```sql
ALTER TABLE "customers" RENAME COLUMN "name" TO "full_name";
```

### Example: Renaming a Field Used in Edge (Foreign Key)

**Intent:**

```yaml
- kind: rename_field
  scope: data
  entity: Todo
  from: user_id
  to: owner_id
```

**Before:**

`ent/schema/todo.go`:

```go
func (Todo) Fields() []ent.Field {
    return []ent.Field{
        field.Int("id").Positive().Unique(),
        field.String("description"),
        field.Int("user_id"),
    }
}

func (Todo) Edges() []ent.Edge {
    return []ent.Edge{
        edge.To("user", User.Type).
            Field("user_id").
            Unique().
            Required(),
    }
}
```

**After:**

`ent/schema/todo.go`:

```go
func (Todo) Fields() []ent.Field {
    return []ent.Field{
        field.Int("id").Positive().Unique(),
        field.String("description"),
        field.Int("owner_id"),
    }
}

func (Todo) Edges() []ent.Edge {
    return []ent.Edge{
        edge.To("owner", User.Type).
            Field("owner_id").
            Unique().
            Required(),
    }
}
```

**Note**: In this example, we also renamed the edge from "user" to "owner" to maintain consistency with the field name. This is optional but recommended.

**Database Migration:**

```sql
ALTER TABLE "todos" RENAME COLUMN "user_id" TO "owner_id";
```

## Code Generation

### Setup Generation Directive

Create `ent/generate.go`:

```go
package ent

//go:generate go run -mod=mod entgo.io/ent/cmd/ent generate ./schema
```

### Running Generation

```bash
go generate ./ent
```

Or manually:

```bash
go run -mod=mod entgo.io/ent/cmd/ent generate ./ent/schema
```

## Database Connection

### Setup Client

```go
import (
    "context"
    "log"
    "streamify/ent"
    _ "github.com/lib/pq" // PostgreSQL driver
)

func main() {
    client, err := ent.Open("postgres", "host=localhost port=5432 user=postgres dbname=mydb password=postgres sslmode=disable")
    if err != nil {
        log.Fatalf("failed opening connection to postgres: %v", err)
    }
    defer client.Close()

    // Apply migrations (only if database.autorun_migrations is true in project.yaml)
    // Migrations are always created when Ent code is regenerated (go generate ./ent)
    // Check project.yaml for database.autorun_migrations before applying:
    // if database.autorun_migrations: true:
    if err := client.Schema.Create(context.Background()); err != nil {
        log.Fatalf("failed creating schema resources: %v", err)
    }
    // if database.autorun_migrations: false or not set: Migration is ready but not applied
}
```

### Supported Databases

- PostgreSQL: `"postgres"` with `github.com/lib/pq`
- MySQL: `"mysql"` with `github.com/go-sql-driver/mysql`
- SQLite: `"sqlite3"` with `github.com/mattn/go-sqlite3`

## Common Patterns

### Auto-incrementing ID

```go
field.Int("id").
    Positive().
    Unique()
```

### UUID Primary Key

```go
import "github.com/google/uuid"

field.UUID("id", uuid.UUID{}).
    Default(uuid.New).
    Unique()
```

### Timestamps

```go
import "time"

field.Time("created_at").
    Default(time.Now),
field.Time("updated_at").
    Default(time.Now).
    UpdateDefault(time.Now),
```

### Optional Fields with MaxLen

```go
field.String("phone").
    MaxLen(20).
    SchemaType(map[string]string{
        "postgres": "varchar(20)",
        "mysql":    "varchar(20)",
        "sqlite3":  "varchar(20)",
    }).
    Optional()
```

### JSON Fields

```go
field.JSON("metadata", map[string]interface{}{}).
    Optional()
```

### Array Fields

```go
field.Strings("tags").
    Optional()
```

## Error Handling

### Common Errors

**"undefined: ent.Open"**

- Solution: Run `go generate ./ent` to generate Ent code

**"schema not found"**

- Solution: Verify schema file exists in `ent/schema/` directory

**"field already exists"**

- Solution: Check if field was already added in schema

**"relation ambiguity"**

- Solution: Ensure edge names are unique and properly referenced

## Best Practices

1. **Always regenerate Ent code** after schema changes: `go generate ./ent` (this creates migrations)
2. **Check `database.autorun_migrations`** in `project.yaml` before applying migrations:
   - If `true`: Migrations are automatically applied during code generation
   - If `false` or not set: Migrations are created but must be applied manually later
3. **Always apply migrations** after regenerating Ent code - this is **critical** for applying database constraints (UNIQUE, NOT NULL, etc.) (only if `autorun_migrations: true`)
4. **Verify constraints were applied** - after migrations, check that unique constraints and other database-level changes were actually created
5. **Update API endpoints** when adding fields to entities - ensure POST/PATCH handlers accept new fields
6. **Update TypeScript types** if using TypeScript API layer - update `packages/types/index.ts` after schema changes
7. **Use descriptive field names** (snake_case convention)
8. **Add validation** using field methods (`.MaxLen()`, `.Min()`, etc.)
9. **Use enums** for fixed value sets
10. **Apply migrations** in development before production
11. **Keep schema files organized** - one entity per file
12. **Use edges for relations** instead of manual foreign keys
13. **Document complex fields** with comments
14. **Test schema changes** before committing
15. **Use transactions** for multi-entity operations
16. **Handle nullable fields correctly** - Ent returns zero values, check for nil/empty appropriately

**Critical Reminder**: Regenerating Ent code (`go generate ./ent`) creates migrations in the code. Database schema changes (including unique constraints) are **only** applied when you run migrations (`client.Schema.Create()`). Always run both steps in sequence:

1. Update schema file
2. Regenerate Ent code: `go generate ./ent` (creates migrations)
3. Apply migrations (only if `database.autorun_migrations: true`): `client.Schema.Create(context.Background())`
4. Update API endpoints if fields were added/modified
5. Update TypeScript types if using TypeScript API layer

## Type Generation

Ent automatically generates Go types from schemas. After generation:

```go
import "streamify/ent"

// Use generated types
user, err := client.User.
    Create().
    SetEmail("test@example.com").
    SetName("Test User").
    Save(context.Background())
```

## Database Client Usage

### Create

```go
user, err := client.User.
    Create().
    SetEmail("test@example.com").
    SetName("Test User").
    Save(context.Background())
```

### Read

```go
// Find all
users, err := client.User.Query().All(context.Background())

// Find by ID
user, err := client.User.Query().
    Where(user.IDEQ(1)).
    Only(context.Background())

// Find with conditions
users, err := client.User.Query().
    Where(user.StatusEQ("ACTIVE")).
    Order(ent.Desc(user.FieldCreatedAt)).
    All(context.Background())
```

### Update

```go
user, err := client.User.
    UpdateOneID(1).
    SetStatus("INACTIVE").
    Save(context.Background())
```

### Delete

```go
err := client.User.
    DeleteOneID(1).
    Exec(context.Background())
```

### Relations

```go
// Query with relations
todos, err := client.Todo.Query().
    WithUser().
    All(context.Background())

// Create with relation
todo, err := client.Todo.
    Create().
    SetDescription("Task").
    SetUserID(userID).
    Save(context.Background())
```

## Migration Handling

### Auto-Migration (Development)

**CRITICAL:** Migrations are **always created** when Ent code is regenerated (`go generate ./ent`), but only **automatically applied** if `database.autorun_migrations: true` in `project.yaml`.

**Step 1: Always create migrations** (happens automatically when regenerating Ent code):

```bash
go generate ./ent
```

This regenerates Ent code and creates the migration code. The migration is ready but not yet applied to the database.

**Step 2: Apply migrations** (only if `database.autorun_migrations: true`):

**If autorun_migrations is true:**

```go
if err := client.Schema.Create(context.Background()); err != nil {
    log.Fatalf("failed creating schema resources: %v", err)
}
```

**If autorun_migrations is false or not set:**

- Migration is created but not applied automatically
- Apply manually when ready: `client.Schema.Create(context.Background())`

**Important**:

- After regenerating Ent code with `go generate ./ent`, migrations are created in the code
- You **must** apply migrations (only if `autorun_migrations: true`) to update the database
- Unique constraints (`.Unique()`) are **only** created in the database when migrations are applied
- Size constraints (`.MaxLen()`) are **only** applied to the database when migrations are applied
- **Limitation**: Ent's auto-migration (`client.Schema.Create()`) may not always apply size constraints to **existing columns**. If you add `MaxLen()` to an existing column, you may need to:
  1. Drop and recreate the table (development only), OR
  2. Use Ent's migration tools to generate explicit SQL migrations, OR
  3. Manually alter the column using SQL
- Without applying migrations, schema changes exist only in Go code, not in the database

### Verifying Constraints Were Applied

After running migrations, verify constraints were created:

**PostgreSQL:**

**Verify Unique Constraints:**

```sql
-- List all unique constraints on a table
SELECT
    conname AS constraint_name,
    contype AS constraint_type,
    a.attname AS column_name
FROM pg_constraint c
JOIN pg_class t ON c.conrelid = t.oid
JOIN pg_attribute a ON a.attrelid = t.oid AND a.attnum = ANY(c.conkey)
WHERE t.relname = 'users' AND contype = 'u';
```

**Verify Column Size (MaxLen) Constraints:**

```sql
-- Check column data type and character maximum length
SELECT
    column_name,
    data_type,
    character_maximum_length
FROM information_schema.columns
WHERE table_name = 'artists' AND column_name = 'name';

-- Expected result for MaxLen(255):
-- column_name | data_type | character_maximum_length
-- name        | character varying | 255
```

**MySQL:**

```sql
SHOW CREATE TABLE artists;
-- Look for VARCHAR(255) or other size constraints
-- Example: `name` varchar(255) NOT NULL
```

**SQLite:**

```sql
SELECT sql FROM sqlite_master
WHERE type='table' AND name='artists';
-- Look for VARCHAR(255) or CHECK constraints in the CREATE TABLE statement
```

**Important**:

- **PostgreSQL Note**: PostgreSQL displays `character varying` instead of `varchar` in `information_schema.columns`, but they are equivalent. The important thing is that `character_maximum_length` shows the correct value (e.g., 255).
- If `MaxLen()` was specified but the column doesn't show the size constraint in the database:
  1. **For new columns**: `SchemaType()` should ensure the constraint is applied when the column is created
  2. **For existing columns**: Ent's auto-migration (`client.Schema.Create()`) **may not alter existing columns** even with `SchemaType()`. You need to manually alter the column:

     ```sql
     -- For PostgreSQL
     ALTER TABLE users ALTER COLUMN first_name TYPE VARCHAR(255);
     ALTER TABLE users ALTER COLUMN last_name TYPE VARCHAR(255);

     -- Verify the constraint was applied:
     SELECT column_name, data_type, character_maximum_length
     FROM information_schema.columns
     WHERE table_name = 'users' AND column_name IN ('first_name', 'last_name');
     ```

  3. **Alternative for development**: Drop and recreate the table (development only)
  4. **For production**: Use Ent's migration tools (Atlas) to generate explicit SQL migrations

### Production Migrations

For production, consider using:

- `client.Schema.WriteTo()` to generate SQL migrations:
  ```go
  // Generate SQL migration
  if err := client.Schema.WriteTo(context.Background(), os.Stdout); err != nil {
      log.Fatalf("failed writing schema: %v", err)
  }
  ```
- Manual migration scripts for complex changes
- Version control for schema changes
- Migration tools like Atlas or golang-migrate for versioned migrations
