# Ent ORM Implementation Guide

> **Template Version:** 1.0.0  
> **Compatible OIML Versions:** 0.1.x  
> **Compatible Ent Versions:** 0.12.x, 0.13.x, 0.14.x  
> **Last Updated:** 2025-01-27

This guide provides complete implementation instructions for applying OpenIntent data intents when using Ent as the database ORM framework.

## When to Use This Guide

Use this guide when `database.framework` in `project.yaml` is set to `"ent"`.

## Prerequisites

- Go 1.18+ is installed
- Ent is installed: `go get entgo.io/ent/cmd/ent`
- Database driver is installed (e.g., `github.com/lib/pq` for PostgreSQL)
- `ent/schema/` directory exists for schema definitions
- `ent/generate.go` file exists with generation directive

## Project Structure

```
project/
├── ent/
│   ├── generate.go          # Code generation directive
│   ├── schema/              # Schema definitions
│   │   ├── user.go
│   │   └── {entity}.go
│   └── (generated files)    # Auto-generated by ent
├── go.mod
└── main.go
```

## Field Type Mappings

### OpenIntent Type → Ent Type

| OpenIntent Type | Ent Type | Ent Method | Notes |
|----------------|----------|------------|-------|
| `string` | `string` | `field.String()` | Text field |
| `text` | `string` | `field.String()` | Long text content |
| `integer` | `int` | `field.Int()` | 32-bit integer |
| `bigint` | `int64` | `field.Int64()` | 64-bit integer |
| `float` | `float64` | `field.Float64()` | Floating point |
| `boolean` | `bool` | `field.Bool()` | True/false value |
| `datetime` | `time.Time` | `field.Time()` | Date and time |
| `date` | `time.Time` | `field.Time()` | Date only |
| `uuid` | `string` | `field.UUID()` | UUID string |
| `json` | `any` | `field.JSON()` | JSON data |
| `enum` | Custom type | `field.Enum()` | Requires enum values |
| `array` | `[]Type` | `field.Strings()` | Array of strings |
| `bytes` | `[]byte` | `field.Bytes()` | Binary data |

### Field Attributes

| OpenIntent Attribute | Ent Implementation | Database Impact |
|---------------------|-------------------|----------------|
| `required: true` | No `.Optional()` call | NOT NULL constraint |
| `required: false` | Add `.Optional()` | NULL allowed |
| `unique: true` | Add `.Unique()` | **Creates UNIQUE constraint in database** |
| `default: value` | Add `.Default(value)` | DEFAULT value in database |
| `max_length: N` | Add `.MaxLen(N)` for strings + `.SchemaType()` | **VARCHAR(N) constraint in database** |

**Important**: 
- When `unique: true` is specified, `.Unique()` **must** be called on the field. This creates a database-level UNIQUE constraint that prevents duplicate values. After regenerating Ent code, you **must** run migrations to apply this constraint to the database.
- When `max_length: N` is specified, **both** `.MaxLen(N)` **and** `.SchemaType()` should be used to ensure the database column respects the constraint:
  ```go
  field.String("email").
      MaxLen(255).
      SchemaType(map[string]string{
          "postgres": "varchar(255)",
          "mysql":    "varchar(255)",
          "sqlite3":  "varchar(255)",
      })
  ```
  - `.MaxLen(N)` provides application-level validation
  - `.SchemaType()` ensures the database column type is `VARCHAR(N)`, enforcing the constraint at the database level
  - **Without `.SchemaType()`**, Ent may create columns without size constraints, especially for existing columns
  - **With `.SchemaType()`**, Ent will create columns with the correct `VARCHAR(N)` type, ensuring `max_length` is respected

### Special Default Values

- `default: "uuid"` → `.Default(uuid.New)` (requires `github.com/google/uuid`)
- `default: "now"` → `.Default(time.Now)` (for time fields)
- `default: "autoincrement"` → Use `.Int()` with auto-increment in database

## Implementing `add_entity` Intent

### Steps

1. **Read the intent** and extract:
   - Entity name (PascalCase)
   - Array of fields with their types and attributes

2. **Create schema file** in `ent/schema/{entity_lower}.go`:
   ```go
   package schema

   import (
       "entgo.io/ent"
       "entgo.io/ent/schema/field"
   )

   // {EntityName} holds the schema definition for the {EntityName} entity.
   type {EntityName} struct {
       ent.Schema
   }

   // Fields of the {EntityName}.
   func ({EntityName}) Fields() []ent.Field {
       return []ent.Field{
           field.Int("id").
               Positive().
               Unique(),
           field.String("field1").
               MaxLen(255),
           field.String("field2").
               Optional(),
           // ... more fields
       }
   }

   // Edges of the {EntityName}.
   func ({EntityName}) Edges() []ent.Edge {
       return []ent.Edge{
           // Relations go here
       }
   }
   ```

3. **Add enum definitions** (if needed) using `field.Enum()`:
   ```go
   field.Enum("status").
       Values("ACTIVE", "INACTIVE", "PENDING").
       Default("ACTIVE")
   ```

4. **Generate Ent code**:
   ```bash
   go generate ./ent
   ```
   Or manually:
   ```bash
   go run -mod=mod entgo.io/ent/cmd/ent generate ./ent/schema
   ```
   This regenerates the Ent client code but **does not** update the database schema.

5. **Run migrations** - **CRITICAL**: You **must** run migrations to apply schema changes to the database:
   ```go
   if err := client.Schema.Create(context.Background()); err != nil {
       log.Fatalf("failed creating schema resources: %v", err)
   }
   ```
   **Note**: Without running migrations, unique constraints, NOT NULL constraints, and other database-level changes will **not** be applied to the database, even though the Ent code has been regenerated.

### Example: Adding a Customer Entity

**Intent:**
```yaml
- kind: add_entity
  scope: data
  entity: Customer
  fields:
    - name: id
      type: integer
      required: true
    - name: email
      type: string
      max_length: 255
      required: true
      unique: true
    - name: name
      type: string
      max_length: 100
      required: true
    - name: status
      type: enum
      enum_values: [ACTIVE, INACTIVE, PENDING]
      required: true
      default: ACTIVE
    - name: created_at
      type: datetime
      required: true
      default: now
```

**Generated Ent Schema:**
```go
package schema

import (
    "time"
    "entgo.io/ent"
    "entgo.io/ent/schema/field"
)

// Customer holds the schema definition for the Customer entity.
type Customer struct {
    ent.Schema
}

// Fields of the Customer.
func (Customer) Fields() []ent.Field {
    return []ent.Field{
        field.Int("id").
            Positive().
            Unique(),
        field.String("email").
            MaxLen(255).
            SchemaType(map[string]string{
                "postgres": "varchar(255)",
                "mysql":    "varchar(255)",
                "sqlite3":  "varchar(255)",
            }).
            Unique(),
        field.String("name").
            MaxLen(100).
            SchemaType(map[string]string{
                "postgres": "varchar(100)",
                "mysql":    "varchar(100)",
                "sqlite3":  "varchar(100)",
            }),
        field.Enum("status").
            Values("ACTIVE", "INACTIVE", "PENDING").
            Default("ACTIVE"),
        field.Time("created_at").
            Default(time.Now),
    }
}

// Edges of the Customer.
func (Customer) Edges() []ent.Edge {
    return []ent.Edge{}
}
```

## Implementing `add_field` Intent

### Steps

1. **Verify the entity exists** in `ent/schema/{entity_lower}.go`

2. **Locate the `Fields()` method** in the schema file

3. **Add new fields** to the `Fields()` return array following the field type mappings
   - **For `unique: true`**: Always add `.Unique()` - this creates a database UNIQUE constraint
   - **For `required: true`**: Do NOT add `.Optional()` - this creates a NOT NULL constraint
   - **For `required: false`**: Add `.Optional()` - allows NULL values
   - **For `max_length: N`**: Add `.MaxLen(N)` **and** `.SchemaType()` for string fields to ensure database-level enforcement:
     ```go
     field.String("field_name").
         MaxLen(255).
         SchemaType(map[string]string{
             "postgres": "varchar(255)",
             "mysql":    "varchar(255)",
             "sqlite3":  "varchar(255)",
         })
     ```

4. **Add enum definitions** (if needed) using `field.Enum()`

5. **Regenerate Ent code**:
   ```bash
   go generate ./ent
   ```
   This regenerates the Ent client code but **does not** update the database schema.

6. **Run migrations** - **CRITICAL**: You **must** run migrations to apply schema changes to the database:
   ```go
   if err := client.Schema.Create(context.Background()); err != nil {
       log.Fatalf("failed creating schema resources: %v", err)
   }
   ```
   Or use Ent's migration tools to generate SQL migrations for production.

   **Note**: Without running migrations, unique constraints, NOT NULL constraints, and other database-level changes will **not** be applied to the database, even though the Ent code has been regenerated.

   **Important Note on MaxLen() and SchemaType()**: 
   - **For new fields**: Always use both `.MaxLen(N)` and `.SchemaType()` to ensure the database column type is `VARCHAR(N)`:
     ```go
     field.String("field_name").
         MaxLen(255).
         SchemaType(map[string]string{
             "postgres": "varchar(255)",
             "mysql":    "varchar(255)",
             "sqlite3":  "varchar(255)",
         })
     ```
     - `SchemaType()` ensures new columns are created with the correct `VARCHAR(N)` type
   - **For existing fields**: Ent's auto-migration (`client.Schema.Create()`) **does not alter existing columns** even with `SchemaType()`. You **must** manually alter existing columns:
     ```sql
     -- PostgreSQL example
     ALTER TABLE users ALTER COLUMN first_name TYPE VARCHAR(255);
     ```
     - **Note**: In PostgreSQL, the column type will show as `character varying` in `information_schema`, but this is equivalent to `varchar`. Check `character_maximum_length` to verify the size constraint.
     - **Alternative for development**: Drop and recreate the table
     - **For production**: Use Ent's Atlas migration tools to generate explicit SQL migrations

   **Important Note on API Endpoints**: When adding fields to an entity, you should also update any existing POST endpoints for that entity to accept the new fields:
   - **For required fields**: Add them to the request body struct with `binding:"required"`
   - **For optional fields**: Add them as pointer types (`*string`, `*int`, etc.) so they can be `nil` if not provided
   - Update the entity creation code to conditionally set optional fields only if they're not nil
   - Example for optional fields:
     ```go
     var body struct {
         RequiredField string  `json:"required_field" binding:"required"`
         OptionalField *string `json:"optional_field"`
     }
     
     create := client.Entity.Create().SetRequiredField(body.RequiredField)
     if body.OptionalField != nil {
         create = create.SetOptionalField(*body.OptionalField)
     }
     entity, err := create.Save(context.Background())
     ```

### Example: Adding Fields to Customer

**Intent:**
```yaml
- kind: add_field
  scope: data
  entity: Customer
  fields:
    - name: phone
      type: string
      max_length: 20
      required: false
    - name: birthday
      type: date
      required: false
    - name: email
      type: string
      max_length: 255
      required: true
      unique: true
```

**Updated Ent Schema:**
```go
func (Customer) Fields() []ent.Field {
    return []ent.Field{
        field.Int("id").
            Positive().
            Unique(),
        field.String("email").
            MaxLen(255).
            SchemaType(map[string]string{
                "postgres": "varchar(255)",
                "mysql":    "varchar(255)",
                "sqlite3":  "varchar(255)",
            }).
            Unique(),  // Creates UNIQUE constraint in database
        field.String("name").
            MaxLen(100).
            SchemaType(map[string]string{
                "postgres": "varchar(100)",
                "mysql":    "varchar(100)",
                "sqlite3":  "varchar(100)",
            }),
        field.String("phone").        // New field
            MaxLen(20).
            SchemaType(map[string]string{
                "postgres": "varchar(20)",
                "mysql":    "varchar(20)",
                "sqlite3":  "varchar(20)",
            }).
            Optional(),
        field.Time("birthday").       // New field
            Optional(),
        field.Enum("status").
            Values("ACTIVE", "INACTIVE", "PENDING").
            Default("ACTIVE"),
        field.Time("created_at").
            Default(time.Now),
    }
}
```

**After updating the schema:**
1. Regenerate Ent code: `go generate ./ent`
2. **Run migrations** to apply the unique constraint to the database:
   ```go
   if err := client.Schema.Create(context.Background()); err != nil {
       log.Fatalf("failed creating schema resources: %v", err)
   }
   ```
3. Verify the constraint was created:
   ```sql
   -- PostgreSQL example
   SELECT constraint_name, constraint_type 
   FROM information_schema.table_constraints 
   WHERE table_name = 'customers' AND constraint_type = 'UNIQUE';
   ```

## Implementing `add_relation` Intent

### Relation Types

| OpenIntent Relation | Ent Implementation |
|--------------------|-------------------|
| `one_to_one` | `edge.To()` on one side, `edge.From()` on other |
| `one_to_many` | `edge.To()` on many side, `edge.From()` on one side |
| `many_to_one` | `edge.To()` on many side, `edge.From()` on one side |
| `many_to_many` | `edge.To()` on both sides with `edge.From()` |

### Steps for `many_to_one` Relation

1. **Verify both entities exist** in the schema directory

2. **Add edge to source entity** (many side):
   ```go
   import "entgo.io/ent/schema/edge"

   func ({SourceEntity}) Edges() []ent.Edge {
       return []ent.Edge{
           edge.To("{target_entity_lower}", {TargetEntity}.Type).
               Unique().
               Required(),
       }
   }
   ```

3. **Add reverse edge to target entity** (one side):
   ```go
   func ({TargetEntity}) Edges() []ent.Edge {
       return []ent.Edge{
           edge.From("{source_entity_plural}", {SourceEntity}.Type).
               Ref("{target_entity_lower}"),
       }
   }
   ```

4. **Regenerate Ent code**:
   ```bash
   go generate ./ent
   ```

5. **Run migrations** to update database schema

### Example: Todo → User Relation

**Intent:**
```yaml
- kind: add_relation
  scope: schema
  relation:
    source_entity: Todo
    target_entity: User
    kind: many_to_one
    field_name: user_id
    foreign_key:
      local_field: user_id
      target_field: id
    reverse:
      kind: one_to_many
      field_name: todos
```

**Updated Ent Schemas:**

`ent/schema/todo.go`:
```go
import "entgo.io/ent/schema/edge"

func (Todo) Edges() []ent.Edge {
    return []ent.Edge{
        edge.To("user", User.Type).
            Unique().
            Required(),
    }
}
```

`ent/schema/user.go`:
```go
func (User) Edges() []ent.Edge {
    return []ent.Edge{
        edge.From("todos", Todo.Type).
            Ref("user"),
    }
}
```

## Implementing `remove_field` Intent

### Steps

1. **Verify the entity and fields exist** in the schema

2. **Remove the fields** from the `Fields()` method return array

3. **Remove related enum references** if no longer used

4. **Regenerate Ent code**:
   ```bash
   go generate ./ent
   ```
   This regenerates the Ent client code but **does not** update the database schema.

5. **Run migrations** - **CRITICAL**: You **must** run migrations to apply schema changes to the database:
   ```go
   if err := client.Schema.Create(context.Background()); err != nil {
       log.Fatalf("failed creating schema resources: %v", err)
   }
   ```
   **Note**: Without running migrations, field removals, constraint removals, and other database-level changes will **not** be applied to the database, even though the Ent code has been regenerated.

## Code Generation

### Setup Generation Directive

Create `ent/generate.go`:
```go
package ent

//go:generate go run -mod=mod entgo.io/ent/cmd/ent generate ./schema
```

### Running Generation

```bash
go generate ./ent
```

Or manually:
```bash
go run -mod=mod entgo.io/ent/cmd/ent generate ./ent/schema
```

## Database Connection

### Setup Client

```go
import (
    "context"
    "log"
    "streamify/ent"
    _ "github.com/lib/pq" // PostgreSQL driver
)

func main() {
    client, err := ent.Open("postgres", "host=localhost port=5432 user=postgres dbname=mydb password=postgres sslmode=disable")
    if err != nil {
        log.Fatalf("failed opening connection to postgres: %v", err)
    }
    defer client.Close()

    // Run auto-migration
    if err := client.Schema.Create(context.Background()); err != nil {
        log.Fatalf("failed creating schema resources: %v", err)
    }
}
```

### Supported Databases

- PostgreSQL: `"postgres"` with `github.com/lib/pq`
- MySQL: `"mysql"` with `github.com/go-sql-driver/mysql`
- SQLite: `"sqlite3"` with `github.com/mattn/go-sqlite3`

## Common Patterns

### Auto-incrementing ID
```go
field.Int("id").
    Positive().
    Unique()
```

### UUID Primary Key
```go
import "github.com/google/uuid"

field.UUID("id", uuid.UUID{}).
    Default(uuid.New).
    Unique()
```

### Timestamps
```go
import "time"

field.Time("created_at").
    Default(time.Now),
field.Time("updated_at").
    Default(time.Now).
    UpdateDefault(time.Now),
```

### Optional Fields with MaxLen
```go
field.String("phone").
    MaxLen(20).
    SchemaType(map[string]string{
        "postgres": "varchar(20)",
        "mysql":    "varchar(20)",
        "sqlite3":  "varchar(20)",
    }).
    Optional()
```

### JSON Fields
```go
field.JSON("metadata", map[string]interface{}{}).
    Optional()
```

### Array Fields
```go
field.Strings("tags").
    Optional()
```

## Error Handling

### Common Errors

**"undefined: ent.Open"**
- Solution: Run `go generate ./ent` to generate Ent code

**"schema not found"**
- Solution: Verify schema file exists in `ent/schema/` directory

**"field already exists"**
- Solution: Check if field was already added in schema

**"relation ambiguity"**
- Solution: Ensure edge names are unique and properly referenced

## Best Practices

1. **Always regenerate Ent code** after schema changes
2. **Always run migrations** after regenerating Ent code - this is **critical** for applying database constraints (UNIQUE, NOT NULL, etc.)
3. **Verify constraints were applied** - after migrations, check that unique constraints and other database-level changes were actually created
4. **Use descriptive field names** (snake_case convention)
5. **Add validation** using field methods (`.MaxLen()`, `.Min()`, etc.)
6. **Use enums** for fixed value sets
7. **Run migrations** in development before production
8. **Keep schema files organized** - one entity per file
9. **Use edges for relations** instead of manual foreign keys
10. **Document complex fields** with comments
11. **Test schema changes** before committing
12. **Use transactions** for multi-entity operations

**Critical Reminder**: Regenerating Ent code (`go generate ./ent`) only updates Go code. Database schema changes (including unique constraints) are **only** applied when you run migrations (`client.Schema.Create()`). Always run both steps in sequence.

## Type Generation

Ent automatically generates Go types from schemas. After generation:

```go
import "streamify/ent"

// Use generated types
user, err := client.User.
    Create().
    SetEmail("test@example.com").
    SetName("Test User").
    Save(context.Background())
```

## Database Client Usage

### Create
```go
user, err := client.User.
    Create().
    SetEmail("test@example.com").
    SetName("Test User").
    Save(context.Background())
```

### Read
```go
// Find all
users, err := client.User.Query().All(context.Background())

// Find by ID
user, err := client.User.Query().
    Where(user.IDEQ(1)).
    Only(context.Background())

// Find with conditions
users, err := client.User.Query().
    Where(user.StatusEQ("ACTIVE")).
    Order(ent.Desc(user.FieldCreatedAt)).
    All(context.Background())
```

### Update
```go
user, err := client.User.
    UpdateOneID(1).
    SetStatus("INACTIVE").
    Save(context.Background())
```

### Delete
```go
err := client.User.
    DeleteOneID(1).
    Exec(context.Background())
```

### Relations
```go
// Query with relations
todos, err := client.Todo.Query().
    WithUser().
    All(context.Background())

// Create with relation
todo, err := client.Todo.
    Create().
    SetDescription("Task").
    SetUserID(userID).
    Save(context.Background())
```

## Migration Handling

### Auto-Migration (Development)

Ent uses auto-migration by default. **This is required** to apply schema changes including unique constraints, NOT NULL constraints, and other database-level changes:

```go
if err := client.Schema.Create(context.Background()); err != nil {
    log.Fatalf("failed creating schema resources: %v", err)
}
```

**Important**: 
- After regenerating Ent code with `go generate ./ent`, you **must** run migrations
- Unique constraints (`.Unique()`) are **only** created in the database when migrations are run
- Size constraints (`.MaxLen()`) are **only** applied to the database when migrations are run
- **Limitation**: Ent's auto-migration (`client.Schema.Create()`) may not always apply size constraints to **existing columns**. If you add `MaxLen()` to an existing column, you may need to:
  1. Drop and recreate the table (development only), OR
  2. Use Ent's migration tools to generate explicit SQL migrations, OR
  3. Manually alter the column using SQL
- Without migrations, schema changes exist only in Go code, not in the database

### Verifying Constraints Were Applied

After running migrations, verify constraints were created:

**PostgreSQL:**

**Verify Unique Constraints:**
```sql
-- List all unique constraints on a table
SELECT 
    conname AS constraint_name,
    contype AS constraint_type,
    a.attname AS column_name
FROM pg_constraint c
JOIN pg_class t ON c.conrelid = t.oid
JOIN pg_attribute a ON a.attrelid = t.oid AND a.attnum = ANY(c.conkey)
WHERE t.relname = 'users' AND contype = 'u';
```

**Verify Column Size (MaxLen) Constraints:**
```sql
-- Check column data type and character maximum length
SELECT 
    column_name,
    data_type,
    character_maximum_length
FROM information_schema.columns
WHERE table_name = 'artists' AND column_name = 'name';

-- Expected result for MaxLen(255):
-- column_name | data_type | character_maximum_length
-- name        | character varying | 255
```

**MySQL:**
```sql
SHOW CREATE TABLE artists;
-- Look for VARCHAR(255) or other size constraints
-- Example: `name` varchar(255) NOT NULL
```

**SQLite:**
```sql
SELECT sql FROM sqlite_master 
WHERE type='table' AND name='artists';
-- Look for VARCHAR(255) or CHECK constraints in the CREATE TABLE statement
```

**Important**: 
- **PostgreSQL Note**: PostgreSQL displays `character varying` instead of `varchar` in `information_schema.columns`, but they are equivalent. The important thing is that `character_maximum_length` shows the correct value (e.g., 255).
- If `MaxLen()` was specified but the column doesn't show the size constraint in the database:
  1. **For new columns**: `SchemaType()` should ensure the constraint is applied when the column is created
  2. **For existing columns**: Ent's auto-migration (`client.Schema.Create()`) **may not alter existing columns** even with `SchemaType()`. You need to manually alter the column:
     ```sql
     -- For PostgreSQL
     ALTER TABLE users ALTER COLUMN first_name TYPE VARCHAR(255);
     ALTER TABLE users ALTER COLUMN last_name TYPE VARCHAR(255);
     
     -- Verify the constraint was applied:
     SELECT column_name, data_type, character_maximum_length
     FROM information_schema.columns
     WHERE table_name = 'users' AND column_name IN ('first_name', 'last_name');
     ```
  3. **Alternative for development**: Drop and recreate the table (development only)
  4. **For production**: Use Ent's migration tools (Atlas) to generate explicit SQL migrations

### Production Migrations

For production, consider using:
- `client.Schema.WriteTo()` to generate SQL migrations:
  ```go
  // Generate SQL migration
  if err := client.Schema.WriteTo(context.Background(), os.Stdout); err != nil {
      log.Fatalf("failed writing schema: %v", err)
  }
  ```
- Manual migration scripts for complex changes
- Version control for schema changes
- Migration tools like Atlas or golang-migrate for versioned migrations

