# OpenIntent Master Prompt

> **Note**: The full OIML (Open Intent Modeling Language) specification is available in the [`@oiml/schema`](https://www.npmjs.com/package/@oiml/schema) package. This document provides implementation guidance for applying intents in practice.

This document serves as the complete reference for implementing OpenIntent-based code generation. When given an intent file (`intent.yaml`), use this guide to perform actual code changes.

## OpenIntent Concepts

### What is OpenIntent?

OIML (Open Intent Modeling Language) is a global standard for AI-driven development that enables:

- **Declarative Development**: Code is generated by simply declaring intents
- **Standardized Schema**: All intents follow a consistent structure defined in the OpenIntent schema
- **Project Metadata**: Configuration is defined in `project.yaml` files
- **Deterministic Generation**: No guessing - everything is explicitly declared
- **Agent Integration**: IDEs and agents can easily understand and apply intents

### Project Structure

```
.openintent/
├── project.yaml              # Project configuration and metadata
├── AGENTS.md                 # Implementation guide for AI agents
│
└── intents/                  # All intents organized by ticket/issue ID
    ├── POS-1/                # One folder per intent (maps to JIRA/Linear ticket)
    │   ├── intent.yaml       # The declarative specification
    │   ├── plan.yaml         # Execution plan (optional)
    │   └── summary.yaml      # Output summary after execution
    │
    ├── POS-2/
    │   ├── intent.yaml
    │   ├── plan.yaml
    │   └── summary.yaml
    │
    └── FEAT-123/
        ├── intent.yaml
        ├── plan.yaml
        └── summary.yaml
```

**File Naming Standards:**
- `intent.yaml` - The intent specification (validated against OIML schema)
- `plan.yaml` - Optional execution plan breaking down steps
- `summary.yaml` - Output summary documenting what was changed

**Additional Optional Files:**
- `rollback.yaml` - Rollback instructions for reverting changes
- `review.md` - Code review comments and feedback
- `test-results.json` - Test execution results
- `migrations.log` - Database migration logs

## Intent File Schema

All intent file schemas are defined in the [`@oiml/schema`](https://www.npmjs.com/package/@oiml/schema) package. Refer to the schema package for:
- Complete intent structure definitions
- Field validation rules
- Required vs optional fields
- Supported values and enums

**Basic Structure:**
- `version`: Semantic version (required)
- `provenance`: Optional metadata about intent creation
- `intents`: Array of intent specifications

**For complete schema definitions, consult `@oiml/schema` package.**

### Intent Types Overview

#### Database Framework Implementation Guides

**IMPORTANT:** Before generating database schema code for any data intent (`add_entity`, `add_field`, `add_relation`, `remove_field`), you MUST:

1. **Read `project.yaml`** to determine the database configuration
2. **Check the `database.framework` field** to identify the framework (e.g., `"prisma"`, `"sqlalchemy"`, etc.)
   - This framework name will be used in the compatibility check (see "Implementation Workflow" section below) to resolve the compatible versioned guide
   - Do NOT use hardcoded guide URLs - the specific guide version will be determined through compatibility checking
3. **Check framework and OIML version compatibility** (see "Implementation Workflow" → step 3) to resolve the compatible versioned guide
4. **Consult the compatible framework guide** (resolved through compatibility checking) for:
   - Complete field type mappings
   - Implementation steps for each intent type
   - Code examples and templates
   - Migration handling
   - Best practices

The framework-specific guides contain all the details needed for implementation. This document provides high-level intent structure only.

### Supported Intent Types

OpenIntent supports the following intent types. For complete schema definitions, see [`@oiml/schema`](https://www.npmjs.com/package/@oiml/schema).

#### Data Intents (scope: data)
- **`add_entity`**: Create new database models/entities
- **`add_field`**: Add fields to existing entities
- **`add_relation`** (scope: schema): Add relationships between entities
- **`remove_field`**: Remove fields from entities

#### API Intents (scope: api)
- **`add_endpoint`**: Create REST API endpoints

#### UI Intents (scope: ui)
- **`add_component`**: Create UI components (future support)

### Implementation Workflow

For each intent type:

1. **Validate the intent** using the schema from `@oiml/schema`
2. **Read `project.yaml`** to determine frameworks
3. **Check framework and OIML version compatibility**:
   
   Before executing any code changes, verify that a compatible template guide exists:

   a. **Extract versions**:
      - Read `intent.yaml` to get OIML version (e.g., `version: "0.1.0"`)
      - Read `package.json` to get framework version(s):
        - For database intents: Check `prisma` or relevant database package version
        - For API intents: Check `next`, `express`, or relevant API framework version
        - For UI intents: Check `react`, `vue`, or relevant UI framework version

   b. **Locate template manifest**:
      - Templates are organized as: `@oiml/schema/templates/{category}/{framework}/{version}/manifest.json`
      - Categories: `database`, `api`, `ui`
      - Example: `@oiml/schema/templates/database/prisma/1.0.0/manifest.json`

   c. **Validate compatibility**:
      - Read the template's `manifest.json` file
      - Check `compatible_oiml_versions` array (e.g., `["0.1.x"]`)
      - Check `compatible_package_versions` object (e.g., `{ "prisma": ["6.x.x"] }`)
      - Verify installed versions fall within compatible ranges
      - Consider `minimum_versions` and `maximum_versions` constraints

   d. **Use MCP resolve_template tool** (if available):
      ```typescript
      const template = await mcp_oiml_resolve_template({
        intent_schema_version: "0.1.0",     // From intent.yaml
        framework: "prisma",                 // From project.yaml
        framework_version: "6.19.0"          // From package.json
      });
      
      // If compatible, template.template_pack contains the guide URI
      // If incompatible, tool returns error or empty result
      ```

   e. **Halt if incompatible**:
      - **If no compatible template is found, STOP immediately**
      - Do NOT execute any code changes
      - Report error to user with details:
        - Framework name and installed version
        - OIML version from intent file
        - Available template versions
        - Compatibility requirements
      - Example error message:
        ```
        Error: No compatible template found for Prisma 6.19.0 with OIML 0.1.0
        
        Installed versions:
        - Prisma: 6.19.0
        - OIML: 0.1.0
        
        Available templates:
        - @oiml/schema/templates/database/prisma/1.0.0
          Compatible with: OIML 0.1.x, Prisma 6.x.x
        
        Please ensure your framework version is compatible with available templates.
        ```

4. **Consult the compatible framework guide**:

   Use the specific versioned guide that was validated in step 3.

   **For Data Intents** (`add_entity`, `add_field`, `add_relation`, `remove_field`):
   - Use the validated template guide: `@oiml/schema/templates/database/{framework}/{version}/AGENTS.md`
   - Example: `@oiml/schema/templates/database/prisma/1.0.0/AGENTS.md`

   **For API Intents** (`add_endpoint`):
   - Use the validated template guide: `@oiml/schema/templates/api/{framework}/{version}/AGENTS.md`
   - Example: `@oiml/schema/templates/api/next/1.0.0/AGENTS.md`

   **For UI Intents** (`add_component`):
   - Use the validated template guide: `@oiml/schema/templates/ui/{framework}/{version}/AGENTS.md`
   - Example: `@oiml/schema/templates/ui/react/1.0.0/AGENTS.md`

5. **Follow the framework guide's detailed instructions**
6. **Verify generated code** matches project patterns

## Project Configuration (project.yaml)

### Key Sections

**API Configuration:**

```yaml
api:
  framework: next # API framework: next, express, fastapi, etc.
  language: typescript # Language: typescript, javascript, python, etc.
  response: # Response format configuration
    success:
      kind: object # Response kind: object, array, etc.
      format: json # Format: json, xml, etc.
      object: data # Success response wrapper field name
    error:
      kind: object
      format: json
      object: error # Error response wrapper field name
```

**Paths Configuration:**

```yaml
paths:
  api: app/api # API routes directory
  components: app/components # Components directory
  entities: prisma # Prisma schema location
  utils: packages/utils # Utilities directory
  types: packages/types # TypeScript types directory
  tests: tests # Tests directory
```

**Database Configuration:**

```yaml
database:
  type: postgres # Database type
  framework: prisma # Database framework: prisma, mongoose, sqlalchemy, etc.
  schema: prisma/schema.prisma # Schema file path
  connection: env:DATABASE_URL # Connection string (env variable)
```

**UI Configuration:**

```yaml
ui:
  base_components: # Available UI components
    - Input: "@/components/ui/input"
    - Button: "@/components/ui/button"
    - Card: "@/components/ui/card"
  theme:
    primary_color: "#2563eb"
    accent_color: "#f59e0b"
    border_radius: "0.75rem"
```

## Implementation Workflow

When processing an intent file, follow these steps:

### 1. Validate Intent File
- Use OpenIntent MCP server: `mcp_oiml_validate_intent(filePath)` if available
- Verify file exists and is valid YAML
- Validate against schema from `@oiml/schema`
- **Stop immediately if validation fails** - do not apply any code changes

### 2. Read Project Configuration
- Read `.openintent/project.yaml`
- Extract framework configurations:
  - `database.framework` - for data intents
  - `api.framework` - for API intents
  - `ui.framework` - for UI intents
- Note configured paths (`paths.api`, `paths.types`, etc.)

### 3. Check Framework and OIML Version Compatibility
Before processing any intents, verify compatibility:

1. **Extract versions**:
   - Read intent file `version` field (OIML schema version)
   - Read `package.json` to get installed framework versions

2. **Resolve template** using MCP tool (if available):
   ```typescript
   const template = await mcp_oiml_resolve_template({
     intent_schema_version: intentVersion,
     framework: frameworkName,
     framework_version: installedVersion
   });
   ```

3. **Validate compatibility**:
   - Locate template manifest at `@oiml/schema/templates/{category}/{framework}/{version}/manifest.json`
   - Verify versions against `compatible_oiml_versions` and `compatible_package_versions`
   - Check `minimum_versions` and `maximum_versions` constraints

4. **Halt if incompatible**:
   - **STOP immediately if no compatible template is found**
   - Report detailed error to user with version information
   - Do NOT proceed with any code generation

### 4. Process Each Intent
For each intent in the `intents` array:

1. **Identify the intent type** (`kind`)
2. **Use the compatible framework guide** determined in step 3:
   - Data intents → Use `@oiml/schema/templates/database/{framework}/{version}/AGENTS.md`
   - API intents → Use `@oiml/schema/templates/api/{framework}/{version}/AGENTS.md`
   - UI intents → Use `@oiml/schema/templates/ui/{framework}/{version}/AGENTS.md`
   
   The specific version was validated for compatibility in step 3.

3. **Follow the framework guide** for detailed implementation steps
4. **Generate code** according to the guide's instructions

### 5. Verify and Complete
- Check for linting errors
- Verify file paths match `project.yaml` configuration
- Ensure all imports are correct
- Test generated code follows project patterns

**Important**: All detailed implementation steps, code examples, and type mappings are in the framework-specific guides. This document only provides high-level orchestration.

## Code Generation Patterns

All framework-specific code generation patterns, examples, and best practices are documented in the respective implementation guides in `@oiml/schema/templates/`:

### Database Patterns

- **Prisma**: Use the compatible versioned guide resolved through the compatibility check process (see "Implementation Workflow" → step 3). The guide will be located at `@oiml/schema/templates/database/prisma/{version}/AGENTS.md` and contains:
  - Field type mappings
  - Database client usage
  - Migration patterns
  - TypeScript type generation
  - Common patterns and best practices

- **Other database frameworks**: Use the compatible versioned guide resolved through compatibility checking. Available frameworks are in `@oiml/schema/templates/database/`

### API Patterns

- **Next.js**: Use the compatible versioned guide resolved through the compatibility check process (see "Implementation Workflow" → step 3). The guide will be located at `@oiml/schema/templates/api/next/{version}/AGENTS.md` and contains:
  - Route handler templates
  - HTTP method implementations
  - Response structure patterns
  - Error handling patterns
  - Authentication patterns
  - Database client integration

- **Other API frameworks**: See `@oiml/schema/templates/api/` for available guides

### Key Principles

1. **Response Structure**: Always follow `api.response` configuration from `project.yaml`
   - Success responses use `api.response.success.object` field (e.g., `data`)
   - Error responses use `api.response.error.object` field (e.g., `error`)

2. **Type Safety**: Generate proper types for all entities and responses

3. **Error Handling**: Include comprehensive error handling with appropriate HTTP status codes

4. **Database Integration**: Use the database client specified in `database.framework`

**For complete code examples and templates, refer to the framework-specific implementation guides.**

## MCP Server Integration

If available, use the OpenIntent MCP server for validation:

```javascript
// Validate intent file
const validation = await mcp_oiml_validate_intent(filePath);
if (!validation.valid) {
  throw new Error(`Invalid intent: ${validation.message}`);
}
```

## Best Practices

1. **Always validate**: Use MCP server validation when available
2. **Follow conventions**: Match existing code patterns in the project
3. **Type safety**: Always use TypeScript types, never `any`
4. **Error handling**: Include comprehensive error handling
5. **Code organization**: Respect project.yaml paths and structure
6. **Migration safety**: Always create migrations for schema changes
7. **Documentation**: Add comments for complex logic
8. **Testing**: Generate test-friendly code structures

## Example: Processing an Intent File

**Given**: An intent file with `add_entity` and `add_endpoint` intents (see `@oiml/schema` for structure)

**Workflow**:

1. ✅ **Validate** intent file against schema
2. ✅ **Read** `.openintent/project.yaml`
3. ✅ **Process** `add_entity` intent:
   - Consult database framework guide (e.g., Prisma guide)
   - Add model to schema
   - Create migration
   - Update TypeScript types
4. ✅ **Process** `add_endpoint` intent:
   - Consult API framework guide (e.g., Next.js guide)
   - Create route handler file
   - Implement HTTP method
   - Add response types
5. ✅ **Verify** all generated code
6. ✅ **Create** output summary file

---

## Output Summary

After successfully applying intents, create an output summary file:

1. **Location**: `.openintent/intents/{INTENT-ID}/summary.yaml`
   - Example: `intents/POS-1/intent.yaml` → `intents/POS-1/summary.yaml`
   - Co-located with the intent file for easy traceability

2. **Structure**: Document all changes made (see `@oiml/schema` for output schema)
   ```yaml
   version: 0.1.0
   applied_at: 2025-11-08T12:34:56Z
   status: success  # "success" | "partial" | "failed"
   intents_processed: 6
   model: claude-sonnet-4.5
   template_used:
     framework: prisma
     category: database
     pack: oiml://compat/oiml-prisma/1.0.0
     version: 1.0.0
     digest: sha256-444a55ffe875c6269eee613cdee0aeb5015853aeb4e9466c24f08e0388683661
     compat:
       oiml: '>=0.1.0 <0.2.0'
       prisma: '>=6.0.0 <7.0.0'
   changes:
     - file: prisma/schema.prisma
       action: modified
       description: Added User, Post, Profile models with relations
     - file: app/api/users/route.ts
       action: created
       description: Created POST endpoint for user creation
     - file: app/api/profiles/route.ts
       action: created
       description: Created GET endpoint for profiles
     - file: prisma/migrations/20251105223004_add_blog_entities/migration.sql
       action: created
       description: Generated Prisma migration for new entities
   errors: []  # Array of any errors encountered
   ```

3. **Key Fields**:
   - `version`: OIML schema version
   - `applied_at`: ISO8601 UTC timestamp of execution
   - `status`: Execution status ("success", "partial", "failed")
   - `intents_processed`: Number of intents successfully processed
   - `model`: AI model used (e.g., "claude-sonnet-4.5")
   - `template_used`: Template pack information (resolved via MCP `resolve_template` tool)
     - `framework`: Framework name (e.g., "prisma", "next")
     - `category`: Framework category ("database", "api", "ui")
     - `pack`: Template pack URI (e.g., "oiml://compat/oiml-prisma/1.0.0")
     - `version`: Template version
     - `digest`: Content digest for verification
     - `compat`: Compatibility constraints
   - `changes[]`: Detailed list of all file changes with actions and descriptions
   - `errors[]`: Any errors encountered during execution

4. **Template Resolution**: Use the MCP `resolve_template` tool to determine which template pack to use:
   ```typescript
   // Example: Resolve template for Prisma
   const template = await mcp.resolve_template({
     intent_schema_version: "0.1.0",  // From intent file
     framework: "prisma",              // From project.yaml
     framework_version: "6.19.0"       // From package.json
   });
   
   // Use template.template_pack for implementation guidance
   // Include template info in summary.yaml
   ```

**Remember**: This is a declarative specification system. When you receive an intent file, you MUST perform the actual code changes - not just log what you would do. The intent IS the instruction to generate code.
