# OpenIntent Master Prompt

> **Note**: The full OIML (Open Intent Modeling Language) specification is available in the [`@oiml/schema`](https://www.npmjs.com/package/@oiml/schema) package. This document provides implementation guidance for applying intents in practice.

This document serves as the complete reference for implementing OpenIntent-based code generation. When given an intent file (`.oiml.yaml`), use this guide to perform actual code changes.

## OpenIntent Concepts

### What is OpenIntent?
OIML (Open Intent Modeling Language) is a global standard for AI-driven development that enables:
- **Declarative Development**: Code is generated by simply declaring intents
- **Standardized Schema**: All intents follow a consistent structure defined in the OpenIntent schema
- **Project Metadata**: Configuration is defined in `project.yaml` files
- **Deterministic Generation**: No guessing - everything is explicitly declared
- **Agent Integration**: IDEs and agents can easily understand and apply intents

### Project Structure
```
.openintent/
├── project.yaml              # Project configuration and metadata
└── intents/                  # Intent files (.oiml.yaml)
    ├── add-customer.oiml.yaml
    ├── add-product.oiml.yaml
    └── add-order.oiml.yaml
```

## Intent File Schema

### Document Structure
```yaml
version: "0.1.0"              # Semantic version (required)
provenance:                    # Optional metadata
  created_by:
    type: "human" | "agent" | "system"
    name: "Creator Name"
    id: "optional-id"
  created_at: "2025-10-28T12:34:56Z"  # ISO8601 UTC format
  source: "builder-ui"         # Optional source identifier
  model: "gpt-4"               # Optional model name if generated

intents:                       # Array of intent specifications
  - kind: add_entity | add_field | add_endpoint | add_component | x-*
    scope: data | api | ui
    # ... intent-specific fields
```

### Intent Types

#### Field Type Mapping (Shared for all data intents)

**IMPORTANT:** Before generating database schema code for any data intent (`add_entity`, `add_field`), you MUST:

1. Read `project.yaml` to determine the database configuration
2. Check the `database.schema` field:
   - If `database.schema` contains `"prisma"` → Use **Prisma** mapping guide: `@oiml/schema/db/prisma.md`
   - If using raw SQL (no ORM) → Use **PostgreSQL** mapping guide: `@oiml/schema/db/postgres.md`
3. Consult the appropriate mapping file for complete field type mappings, examples, and generation rules

The mapping files contain comprehensive information on:
- All supported OpenIntent field types (`string`, `text`, `integer`, `bigint`, `float`, `decimal`, `boolean`, `datetime`, `date`, `time`, `uuid`, `json`, `enum`, `array`, `bytes`)
- How to map each type to the target database format
- Handling field attributes (`required`, `unique`, `default`, `max_length`, `array_type`, `enum_values`)
- Special cases and edge cases
- Complete examples with before/after code

**Field Specification:**
```yaml
fields:
  - name: field_name           # Field name
    type: string               # Field type (see mapping files above)
    required: true             # Optional: boolean
    unique: true               # Optional: boolean
    default: "value"           # Optional: default value
    max_length: 255            # Optional: max length for string/text
    array_type: string         # Required if type is "array"
    enum_values: [...]         # Required if type is "enum"
    api:                       # Optional: API endpoint configuration (for add_field intent)
      include: true            # Whether to include this field in API endpoints
      endpoints:               # Optional: specific endpoints (if omitted, applies to all)
        - "GET /api/customers" # Method + path
        - "/api/customers"     # Just path (all methods)
        - "POST"               # Just method (all paths)
        - "*"                  # All endpoints
```

#### 1. `add_entity` (scope: data)
Adds database models/entities to the database schema.

```yaml
- kind: add_entity
  scope: data
  entity: Customer              # Entity name (PascalCase)
  fields:                       # Array of field specifications (see Field Type Mapping above)
    - name: id
      type: uuid
      required: true
    - name: email
      type: string
      max_length: 255
      required: true
      unique: true
```

**Implementation Steps:**
1. Read `project.yaml` to get database type and schema path
2. Determine if using Prisma or raw SQL based on `database.schema`
3. **Consult the appropriate mapping file** (see Field Type Mapping above) for complete type mappings and generation rules
4. Parse the entity and fields from the intent
5. Generate schema code based on the database type:

   **If using Prisma:**
   - Add the new model to the Prisma schema file following Prisma mapping rules
   - For enum fields, add enum definition before the model if it doesn't exist
   - **MANDATORY: Create and apply database migration:**
     ```bash
     npx prisma migrate dev --name add_{entity_lower}_entity
     ```
     This step **MUST** be executed after modifying the schema. The migration name should follow the pattern `add_{entity_name_lowercase}_entity`.
   - Regenerate Prisma client: `npx prisma generate`

   **If using Raw PostgreSQL:**
   - Generate `CREATE TABLE` statements with proper types and constraints
   - Create enum types first if needed (using `CREATE TYPE`)
   - **MANDATORY: Create and apply migration:**
     - Write SQL migration file: `migrations/{timestamp}_add_{entity_lower}_entity.sql`
     - Apply migration to the database

6. Create/update TypeScript interface in `packages/types/index.ts`:
   - Create new interface matching the entity name (e.g., `{Entity}Interface`)
   - Map all database types to TypeScript types
   - Include response types if needed (e.g., `{Entity}Response`)

**Example Output:**

See complete examples in the appropriate mapping file:
- Prisma: `@oiml/schema/db/prisma.md` → "Complete Example" section
- PostgreSQL: `@oiml/schema/db/postgres.md` → "Complete Example" section

#### 2. `add_field` (scope: data)
Adds fields to an existing database model/entity.

```yaml
- kind: add_field
  scope: data
  entity: Customer              # Existing entity name (PascalCase)
  fields:                       # Array of field specifications to add (see Field Type Mapping above)
    - name: email
      type: string
      max_length: 255
      required: true
      unique: true
      api:                      # Optional: configure which endpoints include this field
        include: true           # Include in API endpoints (default behavior if omitted)
        endpoints:              # Optional: specify which endpoints (if omitted, all endpoints for entity)
          - "GET /api/customers"
          - "POST /api/customers"
    - name: internal_notes      # Example: field that should NOT be in API
      type: text
      api:
        include: false          # Exclude from all API endpoints
```

**Implementation Steps:**
1. Read `project.yaml` to get database type and schema path
2. Determine if using Prisma or raw SQL based on `database.schema`
3. **Verify the entity exists** in the schema before adding fields
4. **Consult the appropriate mapping file** (see Field Type Mapping above) for complete type mappings and generation rules
5. Parse the entity and fields from the intent
6. Generate schema modifications based on the database type:

   **If using Prisma:**
   - Locate the existing model in the Prisma schema file
   - Add new fields to the model following Prisma mapping rules
   - For enum fields, add enum definition before the model if it doesn't exist
   - **MANDATORY: Create and apply database migration:**
     ```bash
     npx prisma migrate dev --name add_{entity_lower}_{field_names}
     ```
     This step **MUST** be executed after modifying the schema. The migration name should follow the pattern `add_{entity_name}_{field_names}` (e.g., `add_customer_birthday` or `add_customer_birthday_anniversary` for multiple fields).
   - Regenerate Prisma client: `npx prisma generate`

   **If using Raw PostgreSQL:**
   - Generate `ALTER TABLE` statements to add columns
   - Create enum types first if needed (using `CREATE TYPE`)
   - Add columns with proper types, constraints, and defaults
   - **MANDATORY: Create and apply migration:**
     - Write SQL migration file: `migrations/{timestamp}_add_{entity_lower}_{field_names}.sql`
     - Apply migration to the database

7. Update TypeScript types in `packages/types/index.ts`:
   - Update the existing interface to include new fields
   - Map database types to TypeScript types

8. **Update existing API endpoints** (if `api.include` is true or not specified):
   - For each field with `api.include: true` (or omitted), update relevant endpoints
   - Check `api.endpoints` to determine which endpoints to update:
     - If `endpoints` is specified, only update matching endpoints
     - If `endpoints` is omitted, update all endpoints for the entity
   - For **GET** endpoints: Include field in response types and return data
   - For **POST** endpoints: Add field to request body types and creation logic
   - For **PATCH** endpoints: Add field to request body types and update logic
   - For **DELETE** endpoints: Typically no changes needed (uses id only)
   - If `api.include: false`, ensure field is excluded from API request/response types

**Example Output:**

**For Prisma Schema:**
```prisma
// Adding fields to existing model
model Customer {
  id         String   @id @default(cuid())
  email      String   @unique @db.VarChar(255)  // New field
  created_at DateTime @default(now())
  updated_at DateTime @updatedAt

  @@map("customers")
}
```

**For Raw PostgreSQL:**
```sql
-- Add column to existing table
ALTER TABLE customers 
ADD COLUMN email VARCHAR(255) NOT NULL UNIQUE;
```

See complete field mapping details in the Field Type Mapping section above.

#### 3. `add_relation` (scope: data/schema)
Adds relationships between existing database models/entities.

```yaml
- kind: add_relation
  scope: schema              # Note: scope is "schema" for relations
  relation:
    source_entity: Todo      # Entity where the relation field will be added
    target_entity: User      # Entity being referenced
    kind: many_to_one        # Relation type: one_to_one, one_to_many, many_to_one, many_to_many
    field_name: user_id      # Foreign key field name on source entity
    foreign_key:
      local_field: user_id   # Field name on source entity
      target_field: id       # Field name on target entity (usually "id")
    reverse:                 # Optional: reverse relation on target entity
      kind: one_to_many      # Must be inverse of relation.kind
      field_name: todos      # Field name on target entity
    emit_migration: true     # Whether to create migration
```

**Implementation Steps:**
1. Read `project.yaml` to get database type and schema path
2. Determine if using Prisma or raw SQL based on `database.schema`
3. **Verify both entities exist** in the schema before adding the relation
4. Generate relation code based on the database type:

   **If using Prisma:**
   - Add foreign key field to the source model (e.g., `user_id String @db.Uuid`)
   - Add relation field to the source model (e.g., `user User @relation(fields: [user_id], references: [id])`)
   - If `reverse` is specified, add reverse relation to target model (e.g., `todos Todo[]`)
   - **MANDATORY: Create and apply database migration:**
     ```bash
     npx prisma migrate dev --name add_{source_entity_lower}_{target_entity_lower}_relation
     ```
     This step **MUST** be executed after modifying the schema. The migration name should follow the pattern `add_{source_entity}_{target_entity}_relation`.
   - Regenerate Prisma client: `npx prisma generate`

   **If using Raw PostgreSQL:**
   - Generate `ALTER TABLE` statements to add foreign key column to source table
   - Add `FOREIGN KEY` constraint referencing target table
   - Create index on foreign key column for performance
   - **MANDATORY: Create and apply migration:**
     - Write SQL migration file: `migrations/{timestamp}_add_{source_entity}_{target_entity}_relation.sql`
     - Apply migration to the database

5. Update TypeScript types in `packages/types/index.ts`:
   - Update source entity interface to include foreign key field (e.g., `user_id: string`)
   - Optionally update target entity interface if reverse relation fields are needed in API responses

**Example Output:**

**For Prisma Schema:**
```prisma
// Source entity (Todo)
model Todo {
  id          String   @id @default(uuid()) @db.Uuid
  description String   @db.Text
  user_id     String   @db.Uuid                    // Foreign key field
  user        User     @relation(fields: [user_id], references: [id])  // Relation field
  @@map("todos")
}

// Target entity (User)
model User {
  id    String @id @default(uuid()) @db.Uuid
  email String @unique
  todos Todo[]  // Reverse relation
  @@map("users")
}
```

**For Raw PostgreSQL:**
```sql
-- Add foreign key column and constraint
ALTER TABLE todos 
ADD COLUMN user_id UUID NOT NULL,
ADD CONSTRAINT fk_todos_user 
  FOREIGN KEY (user_id) REFERENCES users(id);

-- Create index for performance
CREATE INDEX idx_todos_user_id ON todos(user_id);
```

#### 4. `add_endpoint` (scope: api)
Adds REST API endpoints using Next.js App Router.

```yaml
- kind: add_endpoint
  scope: api
  method: GET | POST | PATCH | DELETE
  path: /api/customers          # Must start with '/'
  entity: Customer              # Optional: hint for scaffolding
  auth:                         # Optional: authentication
    required: false
    roles: ["admin"]            # Optional: role-based access
```

**Implementation Steps:**
1. Read `project.yaml` to get API path (default: `app/api`)
2. Convert path to directory structure: `/api/customers` → `app/api/customers/route.ts`
3. Create directory structure if it doesn't exist
4. Generate route handler based on HTTP method:
   - **GET**: Fetch all entities with pagination, sorting, filtering
   - **POST**: Create new entity
   - **PATCH**: Update entity (requires id in path or body)
   - **DELETE**: Delete entity (requires id in path)
5. Use Prisma client from `@/lib/prisma`
6. Import TypeScript types from `@/packages/types`
7. Include proper error handling with typed responses
8. Return NextResponse with appropriate status codes

**GET Endpoint Template:**
```typescript
import { NextResponse } from 'next/server';
import { prisma } from '@/lib/prisma';
import type { {Entity}Response, ErrorResponse } from '@/packages/types';

export async function GET() {
  try {
    const {entity_plural} = await prisma.{entity_lower}.findMany({
      orderBy: { created_at: 'desc' }
    });

    const response: {Entity}Response = {
      success: true,
      data: {entity_plural},
      count: {entity_plural}.length
    };

    return NextResponse.json(response, { status: 200 });
  } catch (error) {
    console.error('Error fetching {entity_plural}:', error);
    const errorResponse: ErrorResponse = {
      success: false,
      error: error instanceof Error ? error.message : 'Failed to fetch {entity_plural}'
    };
    return NextResponse.json(errorResponse, { status: 500 });
  }
}
```

#### 4. `add_component` (scope: ui)
Adds React components for UI.

```yaml
- kind: add_component
  scope: ui
  component: CustomerList        # Component name (PascalCase, no extension)
  template: List | Form | Custom # Template type
  entity: Customer               # Optional: entity to bind
  display_fields: ["name", "email"]  # Optional: fields to display
  route: /customers              # Optional: page route
```

**Implementation Steps:**
1. Read `project.yaml` to get components path (default: `app/components`)
2. Determine component template:
   - **List**: Display list of entities with cards/grid
   - **Form**: Create/edit form for entity
   - **Custom**: Basic component skeleton
3. Generate React component:
   - Use TypeScript with proper typing
   - Import entity interface from `@/packages/types`
   - Use base components from `project.yaml` ui.base_components if specified
   - Follow theme settings (colors, border radius) from `project.yaml`
4. Create component file: `app/components/{ComponentName}.tsx`
5. If `route` is specified, create page: `app/{route}/page.tsx`

**Component Template (List):**
```typescript
import React from 'react';
import { {Entity}Interface } from '@/packages/types';

interface {Component}Props {
  {entity_plural}: {Entity}Interface[];
}

export default function {Component}({ {entity_plural} }: {Component}Props) {
  return (
    <div className="space-y-4">
      <h2 className="text-2xl font-bold">{Entities}</h2>
      <div className="grid gap-4">
        {entity_plural}.map(({entity}) => (
          <div key={entity}.id className="p-4 border rounded-lg">
            {/* Render entity fields */}
          </div>
        ))}
      </div>
    </div>
  );
}
```

## Project Configuration (project.yaml)

### Key Sections

**Paths Configuration:**
```yaml
paths:
  api: app/api                    # API routes directory
  components: app/components      # Components directory
  entities: prisma                # Prisma schema location
  utils: packages/utils           # Utilities directory
  types: packages/types           # TypeScript types directory
  tests: tests                    # Tests directory
```

**Database Configuration:**
```yaml
database:
  type: postgres                  # Database type
  schema: prisma/schema.prisma    # Prisma schema path
  connection: env:DATABASE_URL    # Connection string (env variable)
```

**UI Configuration:**
```yaml
ui:
  base_components:                # Available UI components
    - Input: "@/components/ui/input"
    - Button: "@/components/ui/button"
    - Card: "@/components/ui/card"
  theme:
    primary_color: "#2563eb"
    accent_color: "#f59e0b"
    border_radius: "0.75rem"
```

## Implementation Workflow

### Step 1: Validate Intent File
1. Use OpenIntent MCP server validation if available: `mcp_openintent_validate_intent(filePath)`
2. Verify intent file exists and is valid YAML
3. Check that all required fields are present
4. If intent file does not exist OR is not valid YAML, quit out of all operations and do not apply any code changes. Show an appropriate error message to the user.

### Step 2: Parse Intent File
1. Read the intent file
2. Extract `version` and `provenance` (for logging/auditing)
3. Process each intent in the `intents` array
4. For each intent, extract:
   - `kind`: Intent type
   - `scope`: Domain (data/api/ui)
   - Intent-specific fields

### Step 3: Read Project Configuration
1. Read `.openintent/project.yaml`
2. Extract paths, database, UI, and other configuration
3. Use these values to determine file locations and code structure

### Step 4: Apply Each Intent

#### For `add_entity`:
1. Parse entity name and fields
2. Map OpenIntent field types to Prisma types
3. Generate Prisma model and append to schema
4. **MANDATORY: Create and apply database migration:**
   ```bash
   npx prisma migrate dev --name add_{entity_lower}_entity
   ```
5. Regenerate Prisma client: `npx prisma generate`
6. Create/update TypeScript interface in `packages/types/index.ts`

#### For `add_field`:
1. Parse entity name and fields to add
2. Verify entity exists in schema
3. Map OpenIntent field types to Prisma types
4. Add fields to existing Prisma model
5. **MANDATORY: Create and apply database migration:**
   ```bash
   npx prisma migrate dev --name add_{entity_lower}_{field_names}
   ```
   **Note:** If database drift is detected, use `--create-only` to create the migration file without applying:
   ```bash
   npx prisma migrate dev --create-only --name add_{entity_lower}_{field_names}
   ```
6. Regenerate Prisma client: `npx prisma generate`
7. Update TypeScript interface in `packages/types/index.ts`
8. Update existing API endpoints based on `api.include` configuration

#### For `remove_field`:
1. Parse entity name and fields to remove
2. Verify entity exists in schema
3. Verify fields exist in the model
4. Remove fields from existing Prisma model
5. **MANDATORY: Create and apply database migration:**
   ```bash
   npx prisma migrate dev --name remove_{entity_lower}_{field_names}
   ```
   **Note:** If database drift is detected or migration creation fails, manually create the migration:
   - Create directory: `prisma/migrations/{timestamp}_remove_{entity_lower}_{field_names}/`
   - Create `migration.sql` with `ALTER TABLE` statements to drop columns
   - **Important:** Check for existing migrations with the same name to avoid duplicates
6. Regenerate Prisma client: `npx prisma generate`
7. Remove fields from TypeScript interface in `packages/types/index.ts`
8. Update existing API endpoints to remove references to the field(s)

#### For `add_relation`:
1. Parse source and target entities
2. Verify both entities exist in schema
3. Add foreign key field and relation to source model
4. Add reverse relation to target model if specified
5. **MANDATORY: Create and apply database migration:**
   ```bash
   npx prisma migrate dev --name add_{source_entity}_{target_entity}_relation
   ```
6. Regenerate Prisma client: `npx prisma generate`
7. Update TypeScript interfaces if needed

#### For `add_endpoint`:
1. Parse method, path, and entity
2. Create directory structure from path
3. Generate route handler based on HTTP method
4. Import Prisma client and types
5. Add error handling and typed responses
6. Create response types if needed

#### For `add_component`:
1. Parse component name, template, and entity
2. Determine component structure based on template
3. Generate React component with TypeScript
4. Import entity types and base components
5. Apply theme settings from project.yaml
6. Create page route if specified

### Step 5: Verify and Complete
1. Check for linting errors
2. Verify file paths match project.yaml configuration
3. Ensure imports are correct
4. Test that generated code follows project patterns

## Code Generation Patterns

### Prisma Client Usage
```typescript
import { prisma } from '@/lib/prisma';
// Prisma client is already configured with singleton pattern
```

### TypeScript Type Generation
```typescript
// Entity interface
export interface {Entity}Interface {
  id: string;
  // ... fields mapped from Prisma types
  created_at: Date;
  updated_at: Date;
}

// API response types
export interface {Entity}Response {
  success: boolean;
  data: {Entity}Interface[];
  count: number;
}

export interface ErrorResponse {
  success: false;
  error: string;
}
```

### Error Handling Pattern
```typescript
try {
  // Operation
  return NextResponse.json({ success: true, data: result }, { status: 200 });
} catch (error) {
  console.error('Error:', error);
  const errorResponse: ErrorResponse = {
    success: false,
    error: error instanceof Error ? error.message : 'Unknown error'
  };
  return NextResponse.json(errorResponse, { status: 500 });
}
```

## MCP Server Integration

If available, use the OpenIntent MCP server for validation:

```javascript
// Validate intent file
const validation = await mcp_openintent_validate_intent(filePath);
if (!validation.valid) {
  throw new Error(`Invalid intent: ${validation.message}`);
}
```

## Best Practices

1. **Always validate**: Use MCP server validation when available
2. **Follow conventions**: Match existing code patterns in the project
3. **Type safety**: Always use TypeScript types, never `any`
4. **Error handling**: Include comprehensive error handling
5. **Code organization**: Respect project.yaml paths and structure
6. **Migration safety**: Always create migrations for schema changes
7. **Documentation**: Add comments for complex logic
8. **Testing**: Generate test-friendly code structures

## Example: Complete Intent Processing

Given this intent file:
```yaml
version: "0.2.0"
intents:
  - kind: add_entity
    scope: data
    entity: Product
    fields:
      - { name: id, type: string, required: true }
      - { name: name, type: string, required: true }
      - { name: price, type: float, required: true }
  
  - kind: add_endpoint
    scope: api
    method: GET
    path: /api/products
    entity: Product
```

**Actions to perform:**
1. ✅ Validate intent file
2. ✅ Add `Product` model to `prisma/schema.prisma`
3. ✅ Create migration: `add-product-entity`
4. ✅ Add `ProductInterface` to `packages/types/index.ts`
5. ✅ Create `app/api/products/route.ts` with GET handler
6. ✅ Add `ProductsResponse` type
7. ✅ Verify all files are created correctly

---

**Remember**: This is a declarative specification system. When you receive an intent file, you MUST perform the actual code changes - not just log what you would do. The intent IS the instruction to generate code.