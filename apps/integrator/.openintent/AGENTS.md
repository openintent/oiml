# OpenIntent Master Prompt

> **Note**: The full OIML (Open Intent Modeling Language) specification is available in the [`@oiml/schema`](https://www.npmjs.com/package/@oiml/schema) package. This document provides implementation guidance for applying intents in practice.

This document serves as the complete reference for implementing OpenIntent-based code generation. When given an intent file (`intent.yaml`), use this guide to perform actual code changes.

## OpenIntent Concepts

### What is OpenIntent?

OIML (Open Intent Modeling Language) is a global standard for AI-driven development that enables:

- **Declarative Development**: Code is generated by simply declaring intents
- **Standardized Schema**: All intents follow a consistent structure defined in the OpenIntent schema
- **Project Metadata**: Configuration is defined in `project.yaml` files
- **Deterministic Generation**: No guessing - everything is explicitly declared
- **Agent Integration**: IDEs and agents can easily understand and apply intents

### Project Structure

```
.openintent/
├── project.yaml              # Project configuration and metadata
├── AGENTS.md                 # Implementation guide for AI agents
│
└── intents/                  # All intents organized by ticket/issue ID
    ├── POS-1/                # One folder per intent (maps to JIRA/Linear ticket)
    │   ├── intent.yaml       # The declarative specification
    │   ├── plan.yaml         # Execution plan (optional)
    │   └── summary.yaml      # Output summary after execution
    │
    ├── POS-2/
    │   ├── intent.yaml
    │   ├── plan.yaml
    │   └── summary.yaml
    │
    └── FEAT-123/
        ├── intent.yaml
        ├── plan.yaml
        └── summary.yaml
```

**File Naming Standards:**

- `intent.yaml` - The intent specification (validated against OIML schema)
- `plan.yaml` - Optional execution plan breaking down steps
- `summary.yaml` - Output summary documenting what was changed

**Additional Optional Files:**

- `rollback.yaml` - Rollback instructions for reverting changes
- `review.md` - Code review comments and feedback
- `test-results.json` - Test execution results
- `migrations.log` - Database migration logs

## Intent File Schema

All intent file schemas are defined in the [`@oiml/schema`](https://www.npmjs.com/package/@oiml/schema) package. Refer to the schema package for:

- Complete intent structure definitions
- Field validation rules
- Required vs optional fields
- Supported values and enums

**Basic Structure:**

- `version`: Semantic version (required)
- `provenance`: Optional metadata about intent creation
- `intents`: Array of intent specifications

**For complete schema definitions, consult `@oiml/schema` package.**

### Intent Types Overview

#### Database Framework Implementation Guides

**IMPORTANT:** Before generating database schema code for any data intent (`add_entity`, `add_field`, `add_relation`, `remove_field`), you MUST:

1. **Validate and transform the intent to IR** using `mcp_oiml_transform_to_ir`
   - This converts human-authored intents to a deterministic, framework-agnostic representation
   - All field types are fully resolved (e.g., `"string"` → `{ kind: "Scalar", scalar: "String" }`)
   - All defaults are explicitly stated (table names, primary keys, nullable fields)
   - All validations are normalized (max_length, unique constraints, etc.)
2. **Read `project.yaml`** to determine the database configuration
3. **Check the `database.framework` field** to identify the framework (e.g., `"prisma"`, `"sqlalchemy"`, etc.)
   - This framework name will be used in the compatibility check (see "Implementation Workflow" section below) to resolve the compatible versioned guide
   - Do NOT use hardcoded guide URLs - the specific guide version will be determined through compatibility checking
4. **Check framework and OIML version compatibility** (see "Implementation Workflow" → step 3) to resolve the compatible versioned guide
5. **Consult the compatible framework guide** (resolved through compatibility checking) for:
   - Complete field type mappings
   - Implementation steps for each intent type
   - Code examples and templates
   - Migration handling
   - Best practices
6. **Use the IR object** (not the raw intent) as the source for all code generation

The framework-specific guides contain all the details needed for implementation. This document provides high-level orchestration, and the IR provides the normalized data for code generation.

### Supported Intent Types

OpenIntent supports the following intent types. For complete schema definitions, see [`@oiml/schema`](https://www.npmjs.com/package/@oiml/schema).

#### Data Intents (scope: data)

- **`add_entity`**: Create new database models/entities
- **`add_field`**: Add fields to existing entities
- **`add_relation`** (scope: data): Add relationships between entities
- **`remove_field`**: Remove fields from entities

#### API Intents (scope: api)

- **`add_endpoint`**: Create REST API endpoints
- **`update_endpoint`**: Modify existing API endpoints to include additional fields in responses

#### Capability Intents (scope: capability)

- **`add_capability`**: Add capability modules for common services (auth, file upload, file streaming, SSE, websockets)

#### UI Intents (scope: ui)

- **`add_component`**: Create UI components (future support)

### Implementation Workflow

For each intent type:

1. **Validate the intent** using the schema from `@oiml/schema`
2. **Read `project.yaml`** to determine frameworks
3. **Check framework and OIML version compatibility**:

   Before executing any code changes, verify that a compatible template guide exists:

   a. **Extract versions**:
   - Read `intent.yaml` to get OIML version (e.g., `version: "0.1.0"`)
   - Read `package.json` to get framework version(s):
     - For database intents: Check `prisma` or relevant database package version
     - For API intents: Check `next`, `express`, or relevant API framework version
     - For capability intents: Extract `framework` from intent (e.g., `gin`, `next`, `express`) and check corresponding package version
     - For UI intents: Check `react`, `vue`, or relevant UI framework version

   b. **Locate template manifest**:
   - Templates are organized as: `@oiml/schema/templates/{category}/{framework}/{version}/manifest.json`
   - For capability intents: `@oiml/schema/templates/capability/{capability_type}/{framework}/{version}/manifest.json`
   - Categories: `database`, `api`, `capability`, `ui`
   - Example: `@oiml/schema/templates/database/prisma/1.0.0/manifest.json`
   - Example (capability): `@oiml/schema/templates/capability/auth/gin/1.0.0/manifest.json`

   c. **Validate compatibility**:
   - Read the template's `manifest.json` file
   - Check `compatible_oiml_versions` array (e.g., `["0.1.x"]`)
   - Check `compatible_package_versions` object (e.g., `{ "prisma": ["6.x.x"] }`)
   - Verify installed versions fall within compatible ranges
   - Consider `minimum_versions` and `maximum_versions` constraints

   d. **Use MCP resolve_template tool** (if available):

   ```typescript
   const template = await mcp_oiml_resolve_template({
     intent_schema_version: "0.1.0", // From intent.yaml
     framework: "prisma", // From project.yaml
     framework_version: "6.19.0" // From package.json
   });

   // If compatible, template.template_pack contains the guide URI
   // If incompatible, tool returns error or empty result
   ```

   e. **Halt if incompatible**:
   - **If no compatible template is found, STOP immediately**
   - Do NOT execute any code changes
   - Report error to user with details:
     - Framework name and installed version
     - OIML version from intent file
     - Available template versions
     - Compatibility requirements
   - Example error message:

     ```
     Error: No compatible template found for Prisma 6.19.0 with OIML 0.1.0

     Installed versions:
     - Prisma: 6.19.0
     - OIML: 0.1.0

     Available templates:
     - @oiml/schema/templates/database/prisma/1.0.0
       Compatible with: OIML 0.1.x, Prisma 6.x.x

     Please ensure your framework version is compatible with available templates.
     ```

4. **Consult the compatible framework guide**:

   Use the specific versioned guide that was validated in step 3.

   **For Data Intents** (`add_entity`, `add_field`, `add_relation`, `remove_field`):
   - Use the validated template guide: `@oiml/schema/templates/database/{framework}/{version}/AGENTS.md`
   - Example: `@oiml/schema/templates/database/prisma/1.0.0/AGENTS.md`

   **For API Intents** (`add_endpoint`, `update_endpoint`):
   - Use the validated template guide: `@oiml/schema/templates/api/{framework}/{version}/AGENTS.md`
   - Example: `@oiml/schema/templates/api/next/1.0.0/AGENTS.md`

   **For Capability Intents** (`add_capability`):
   - Use the validated template guide: `@oiml/schema/templates/capability/{capability_type}/{framework}/{version}/AGENTS.md`
   - Example: `@oiml/schema/templates/capability/auth/gin/1.0.0/AGENTS.md`
   - Capability types: `auth`, `file_upload`, `file_stream`, `sse`, `websocket`

   **For UI Intents** (`add_component`):
   - Use the validated template guide: `@oiml/schema/templates/ui/{framework}/{version}/AGENTS.md`
   - Example: `@oiml/schema/templates/ui/react/1.0.0/AGENTS.md`

5. **Follow the framework guide's detailed instructions**
6. **Verify generated code** matches project patterns

## Project Configuration (project.yaml)

### Key Sections

**API Configuration:**

```yaml
api:
  framework: next # API framework: next, express, fastapi, etc.
  language: typescript # Language: typescript, javascript, python, etc.
  response: # Response format configuration
    success:
      kind: object # Response kind: object, array, etc.
      format: json # Format: json, xml, etc.
      object: data # Success response wrapper field name
    error:
      kind: object
      format: json
      object: error # Error response wrapper field name
```

**Paths Configuration:**

```yaml
paths:
  api: app/api # API routes directory
  components: app/components # Components directory
  entities: prisma # Prisma schema location
  utils: packages/utils # Utilities directory
  types: packages/types # TypeScript types directory
  tests: tests # Tests directory
```

**Database Configuration:**

```yaml
database:
  type: postgres # Database type
  framework: prisma # Database framework: prisma, mongoose, sqlalchemy, etc.
  schema: prisma/schema.prisma # Schema file path
  connection: env:DATABASE_URL # Connection string (env variable)
```

**UI Configuration:**

```yaml
ui:
  base_components: # Available UI components
    - Input: "@/components/ui/input"
    - Button: "@/components/ui/button"
    - Card: "@/components/ui/card"
  theme:
    primary_color: "#2563eb"
    accent_color: "#f59e0b"
    border_radius: "0.75rem"
```

## Implementation Workflow

When processing an intent file, follow these steps:

### 1. Validate Intent File

- Use OpenIntent MCP server: `mcp_oiml_validate_intent(filePath)` if available
- Verify file exists and is valid YAML
- Validate against schema from `@oiml/schema`
- **Stop immediately if validation fails** - do not apply any code changes

### 2. Read Project Configuration

- Read `.openintent/project.yaml`
- Extract framework configurations:
  - `database.framework` - for data intents
  - `api.framework` - for API intents (also used for capability intents)
  - `ui.framework` - for UI intents
- Note configured paths (`paths.api`, `paths.types`, etc.)
- For capability intents: Extract `framework` and `capability` fields from the intent itself

### 3. Check Framework and OIML Version Compatibility

Before processing any intents, verify compatibility:

1. **Extract versions**:
   - Read intent file `version` field (OIML schema version)
   - Read `package.json` to get installed framework versions
   - For capability intents: Extract `capability` and `framework` fields from the intent to determine the template path

2. **Resolve template** using MCP tool (if available):

   ```typescript
   const template = await mcp_oiml_resolve_template({
     intent_schema_version: intentVersion,
     framework: frameworkName,
     framework_version: installedVersion
   });
   ```

3. **Validate compatibility**:
   - Locate template manifest:
     - For capability intents: `@oiml/schema/templates/capability/{capability_type}/{framework}/{version}/manifest.json`
     - For other intents: `@oiml/schema/templates/{category}/{framework}/{version}/manifest.json`
   - Verify versions against `compatible_oiml_versions` and `compatible_package_versions`
   - Check `minimum_versions` and `maximum_versions` constraints

4. **Halt if incompatible**:
   - **STOP immediately if no compatible template is found**
   - Report detailed error to user with version information
   - Do NOT proceed with any code generation

### 4. Transform Intent to Intermediate Representation (IR)

Before generating any code, transform the human-authored intent file to its Intermediate Representation (IR):

1. **Call the transform_to_ir MCP tool**:

   ```typescript
   const result = await mcp_oiml_transform_to_ir({
     content: intentFileContent, // Raw YAML/JSON content
     format: "yaml", // or "json"
     intentId: "FEAT-123", // Optional: Intent ID for provenance
     projectId: "my-project" // Optional: Project ID for provenance
   });
   ```

2. **Extract the IR**:
   - The tool returns a structured IR object with:
     - `success`: boolean indicating transformation success
     - `ir`: Array of IR objects (one per intent in the file)
     - `metadata`: Metadata about the transformation
   - Each IR object contains:
     - Fully resolved field types (e.g., `"string"` → `{ kind: "Scalar", scalar: "String" }`)
     - Inferred defaults (table names, primary keys, nullable fields, etc.)
     - Storage configuration (table name, primary key strategy)
     - Validation rules (max length, unique constraints, etc.)
     - Provenance information (intent ID, project ID, timestamps)
     - Diagnostics (warnings, info messages about inferences)

3. **Use IR for code generation**:
   - **IMPORTANT**: Use the IR objects (not the original intent.yaml) as the source for all code generation
   - The IR is a deterministic, normalized, framework-agnostic representation
   - Benefits of using IR:
     - No ambiguity - all types are fully resolved
     - No guessing - all defaults are explicitly stated
     - Consistent output - same IR always produces same code
     - Framework-agnostic - IR is independent of implementation details

4. **Handle transformation errors**:
   - If `success` is false or IR is missing, halt immediately
   - Report any validation or transformation errors to user
   - Do NOT proceed with code generation if IR transformation fails

**Example IR Structure** (for reference):

```json
{
  "kind": "AddEntity",
  "irVersion": "1.0.0",
  "provenance": {
    "intentId": "FEAT-123",
    "projectId": "my-project",
    "generatedAt": "2025-11-17T22:57:46.998Z",
    "sourceIntentVersion": "0.1.0"
  },
  "entity": {
    "name": "User",
    "storage": {
      "kind": "RelationalTable",
      "tableName": "users",
      "primaryKey": { "kind": "Single", "field": "id" }
    },
    "fields": [
      {
        "name": "id",
        "type": { "kind": "Scalar", "scalar": "UUID" },
        "nullable": false,
        "isPrimary": true,
        "generated": { "strategy": "UUID" }
      },
      {
        "name": "email",
        "type": { "kind": "Scalar", "scalar": "String" },
        "nullable": false,
        "validations": [{ "kind": "MaxLength", "max": 255 }]
      }
    ]
  },
  "diagnostics": [{ "level": "Info", "code": "IR002", "message": "Inferred table name 'users'" }]
}
```

### 5. Process Each Intent IR

For each IR object in the transformation result:

1. **Identify the intent type** (`kind` field in IR)
2. **Use the IR object** (not the original intent) for code generation
3. **Use the compatible framework guide** determined in step 3:
   - Data intents → Use `@oiml/schema/templates/database/{framework}/{version}/AGENTS.md`
   - API intents (`add_endpoint`, `update_endpoint`) → Use `@oiml/schema/templates/api/{framework}/{version}/AGENTS.md`
   - Capability intents (`add_capability`) → Use `@oiml/schema/templates/capability/{capability_type}/{framework}/{version}/AGENTS.md`
     - Extract `capability_type` from intent (e.g., `auth`, `file_upload`, `file_stream`, `sse`, `websocket`)
     - Extract `framework` from intent (e.g., `gin`, `next`, `express`)
   - UI intents → Use `@oiml/schema/templates/ui/{framework}/{version}/AGENTS.md`

   The specific version was validated for compatibility in step 3.

4. **Follow the framework guide** for detailed implementation steps
5. **Generate code** according to the guide's instructions, using the IR object as the source

**Key Benefits of Using IR**:

- Framework guides can rely on fully resolved types and configurations
- No need for type inference in code generators
- Consistent code generation across all tools and agents
- Better error messages and diagnostics

### 6. Verify and Complete

- Check for linting errors
- Verify file paths match `project.yaml` configuration
- Ensure all imports are correct
- Test generated code follows project patterns

**Important**: All detailed implementation steps, code examples, and type mappings are in the framework-specific guides. This document only provides high-level orchestration.

## Code Generation Patterns

All framework-specific code generation patterns, examples, and best practices are documented in the respective implementation guides in `@oiml/schema/templates/`:

### Database Patterns

- **Prisma**: Use the compatible versioned guide resolved through the compatibility check process (see "Implementation Workflow" → step 3). The guide will be located at `@oiml/schema/templates/database/prisma/{version}/AGENTS.md` and contains:
  - Field type mappings
  - Database client usage
  - Migration patterns
  - TypeScript type generation
  - Common patterns and best practices

- **Other database frameworks**: Use the compatible versioned guide resolved through compatibility checking. Available frameworks are in `@oiml/schema/templates/database/`

### API Patterns

- **Next.js**: Use the compatible versioned guide resolved through the compatibility check process (see "Implementation Workflow" → step 3). The guide will be located at `@oiml/schema/templates/api/next/{version}/AGENTS.md` and contains:
  - Route handler templates
  - HTTP method implementations
  - Response structure patterns
  - Error handling patterns
  - Authentication patterns
  - Database client integration

- **Other API frameworks**: See `@oiml/schema/templates/api/` for available guides

### Key Principles

1. **Response Structure**: Always follow `api.response` configuration from `project.yaml`
   - Success responses use `api.response.success.object` field (e.g., `data`)
   - Error responses use `api.response.error.object` field (e.g., `error`)

2. **Type Safety**: Generate proper types for all entities and responses

3. **Error Handling**: Include comprehensive error handling with appropriate HTTP status codes

4. **Database Integration**: Use the database client specified in `database.framework`

**For complete code examples and templates, refer to the framework-specific implementation guides.**

## MCP Server Integration

If available, use the OpenIntent MCP server for validation and transformation:

```javascript
// 1. Validate intent file
const validation = await mcp_oiml_validate_intent(filePath);
if (!validation.valid) {
  throw new Error(`Invalid intent: ${validation.message}`);
}

// 2. Transform intent to IR
const irResult = await mcp_oiml_transform_to_ir({
  content: intentFileContent,
  format: "yaml",
  intentId: "FEAT-123",
  projectId: "my-project"
});

if (!irResult.success) {
  throw new Error("Failed to transform intent to IR");
}

// 3. Use IR for code generation
const irObjects = irResult.ir;
for (const ir of irObjects) {
  // Generate code using the IR object
  // All types are resolved, defaults are explicit
}
```

## Best Practices

1. **Always validate**: Use MCP server validation when available
2. **Always transform to IR**: Use `mcp_oiml_transform_to_ir` to convert intents to IR before generating code
3. **Use IR for code generation**: Never use the raw intent.yaml for code generation - always use the transformed IR
4. **Follow conventions**: Match existing code patterns in the project
5. **Type safety**: Always use TypeScript types, never `any`
6. **Error handling**: Include comprehensive error handling
7. **Code organization**: Respect project.yaml paths and structure
8. **Migration safety**: Always create migrations for schema changes
9. **Documentation**: Add comments for complex logic
10. **Testing**: Generate test-friendly code structures

## Example: Processing an Intent File

**Given**: An intent file with `add_entity` and `add_endpoint` intents (see `@oiml/schema` for structure)

**Workflow**:

1. ✅ **Validate** intent file against schema
2. ✅ **Read** `.openintent/project.yaml`
3. ✅ **Check** framework compatibility and resolve template versions
4. ✅ **Transform** intent file to IR using `mcp_oiml_transform_to_ir`
   - Get fully resolved field types
   - Get inferred defaults (table names, primary keys, etc.)
   - Get validation rules and storage configuration
5. ✅ **Process** `add_entity` IR:
   - Consult database framework guide (e.g., Prisma guide)
   - Use IR object (not raw intent) for code generation
   - Add model to schema
   - Create migration
   - Update TypeScript types
6. ✅ **Process** `add_endpoint` IR:
   - Consult API framework guide (e.g., Next.js guide)
   - Use IR object (not raw intent) for code generation
   - Create route handler file
   - Implement HTTP method
   - Add response types
7. ✅ **Verify** all generated code
8. ✅ **Create** output summary file

---

## Output Summary

After successfully applying intents, create an output summary file:

1. **Location**: `.openintent/intents/{INTENT-ID}/summary.yaml`
   - Example: `intents/POS-1/intent.yaml` → `intents/POS-1/summary.yaml`
   - Co-located with the intent file for easy traceability

2. **Structure**: Document all changes made (see `@oiml/schema` for output schema)

   ```yaml
   version: 0.1.0
   applied_at: 2025-11-08T12:34:56Z
   status: success # "success" | "partial" | "failed"
   intents_processed: 6
   model: claude-sonnet-4.5
   template_used:
     framework: prisma
     category: database
     pack: oiml://compat/oiml-prisma/1.0.0
     version: 1.0.0
     digest: sha256-444a55ffe875c6269eee613cdee0aeb5015853aeb4e9466c24f08e0388683661
     compat:
       oiml: ">=0.1.0 <0.2.0"
       prisma: ">=6.0.0 <7.0.0"
   changes:
     - file: prisma/schema.prisma
       action: modified
       description: Added User, Post, Profile models with relations
     - file: app/api/users/route.ts
       action: created
       description: Created POST endpoint for user creation
     - file: app/api/profiles/route.ts
       action: created
       description: Created GET endpoint for profiles
     - file: prisma/migrations/20251105223004_add_blog_entities/migration.sql
       action: created
       description: Generated Prisma migration for new entities
   errors: [] # Array of any errors encountered
   ```

3. **Key Fields**:
   - `version`: OIML schema version
   - `applied_at`: ISO8601 UTC timestamp of execution
   - `status`: Execution status ("success", "partial", "failed")
   - `intents_processed`: Number of intents successfully processed
   - `model`: AI model used (e.g., "claude-sonnet-4.5")
   - `template_used`: Template pack information (resolved via MCP `resolve_template` tool)
     - `framework`: Framework name (e.g., "prisma", "next")
     - `category`: Framework category ("database", "api", "ui")
     - `pack`: Template pack URI (e.g., "oiml://compat/oiml-prisma/1.0.0")
     - `version`: Template version
     - `digest`: Content digest for verification
     - `compat`: Compatibility constraints
   - `changes[]`: Detailed list of all file changes with actions and descriptions
   - `errors[]`: Any errors encountered during execution

4. **Template Resolution**: Use the MCP `resolve_template` tool to determine which template pack to use:

   ```typescript
   // Example: Resolve template for Prisma
   const template = await mcp.resolve_template({
     intent_schema_version: "0.1.0", // From intent file
     framework: "prisma", // From project.yaml
     framework_version: "6.19.0" // From package.json
   });

   // Use template.template_pack for implementation guidance
   // Include template info in summary.yaml
   ```

**Remember**: This is a declarative specification system. When you receive an intent file, you MUST perform the actual code changes - not just log what you would do. The intent IS the instruction to generate code.
